\begin{figure*}
\centering
\vspace{4ex}

\begin{tabular}{l p{0.53\linewidth}}
$\axiom : U \to U$ & Produces type of universe\\
$\rules : U \times U \to U$ & Produces universe of product type given universe of argument and return types \\
$\elim : U \times U \times \mathcal{I} \to ()$ & Checks that given universe $\varw_k$ of \coinductive type $I_k$ of case expression target can be eliminated to a type with given universe $\varw$; can fail \\
$\cdot \preceq \cdot : T \times T \to \P(S \times S)$ & Checks subtypeability and produces a size constraint set; can fail \\
$\fresh : \N^+ \to \vec{\mathcal{V}}$ & Produces given number of fresh size variables, putting them into $\mathcal{V}$ \\
$\decompose : T \times \N^0 \to \Delta \times T$ & Splits function type into given number of arguments and return type; can fail \\
$\casesize : \mathcal{I} \times S \times \mathcal{V} \to \P(S \times S)$ & Given \coinductive type $I_k$, size expression $s$, and size variable $\upsilon_k$, returns $\set{s \sqsubseteq \hat{\upsilon}_k}$ if $I_k$ is inductive and $\set{\hat{\upsilon}_k \sqsubseteq s}$ if $I_k$ is coinductive \\
$\shift : T \to T$ & Replaces each position size annotation by successor \\
$\setrecstars : T^\circ \times \N^+ \to T^*$ & Given index $n$, annotates $n$th argument type $I$ and all other argument and return types with same type $I$ with position annotations; can fail \\
$\setcorecstars : T^\circ \to T^*$ & Annotates return argument type $I$ and all other argument types with same type $I$ with position annotations; can fail \\
$\getrecvar : T \times \N^+ \to \mathcal{V}^*$ & Given index $n$, retrieves position size variable of $n$th argument type; can fail \\
$\getcorecvar : T \to \mathcal{V}^*$ & Retrieve position size variable of return type; can fail \\
$\erasetoglobal : T \times T \to T^\iota $ & Given a terms $u$ and $t$, erase $t$ to a global term such that global annotations appear in $t$ where position size variables appear in $u$ \\
$\RecCheckLoop : C \times \Gamma \times \vec{\mathcal{V}^*} \times \vec{T} \times \vec{T} \to C$ & Calls \textsc{RecCheck} recursively, shrinking $\mathcal{V}^*$ each time; can fail via \textsc{RecCheck} \\
$\RecCheck : C \times \mathcal{V}^* \times \P(\mathcal{V}^*) \times \P(\mathcal{V}) \to C$ & Checks termination and productivity using size constraints, returning a new set of constraints; can fail
\end{tabular}
\vspace{2ex}
\caption{Summary of metafunctions used in the size inference algorithm}
\label{fig:inference-metafunctions}
\end{figure*}
