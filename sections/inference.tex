\section{Size Inference}\label{sec:algorithm}

In this section, we present a size inference algorithm, based on that of \CIChat~\citep{cic-hat}.
Starting with completely bare terms, corresponding to terms in CIC,
the algorithm assigns size annotations while collecting a set of subsizing constraints.
Because the subsizing constraints that must be satisfied are based on the typing rules,
this algorithm is also necessarily a type checking algorithm,
ensuring well-typedness of the size-annotated term.
Then given a program consisting of bare global declarations,
the algorithm produces sized and well-typed declarations (or fails),
along with a set of constraints on the size variables involved.

Before we add the declarations back into a sized global environment,
we find a solution for the constraints first.
That is, we find an assignment from size variables to size expressions
such that these size expressions satisfy all of the constraints.
Then we perform the substitution of these assignments on the declarations,
and lastly add them into the global environment.
This lets us run the inference algorithm on each declaration independently,
without needing to manipulate a constraint set every time a global declaration is used in a subsequent one.

One of the most involved parts of the algorithm is the size inference and type checking of \cofixpoints.
This uses the \RecCheck algorithm from \Fhat~\citep{f-hat}.
We restate the algorithm in this section for convenience, but not the associated proofs of soundness and completeness.
The other notably involved part of the algorithm is the \solve algorithm,
which given a set of constraints produces a valid solution.
Finally, we state soundness and completeness theorems for the algorithm as a whole,
proving only soundness and leaving completeness as a conjecture.

\subsection{Preliminaries}

We first formally define the notions of constraints and solutions,
as well as some additional notation.

\begin{definition}
A \textbf{subsizing constraint set} (or simply \textbf{constraint set}) $C$ is a set of pairs of size expressions $s_1 \sqsubseteq s_2$ (also referred to as a \textbf{constraint})
representing a subsizing relation from $s_1$ to $s_2$ that must be enforced.
(When ambiguous, we will explicitly distinguish between the \emph{constraint} $s_1 \sqsubseteq s_2$ and the \emph{judgement} $s_1 \sqsubseteq s_2$.)

We write $s_1 = s_2$ to mean the two pairs $s_1 \sqsubseteq s_2$ and $s_2 \sqsubseteq s_1$.
Given a set of size variables $V$, we also write $\upsilon \sqsubseteq V$ for the pointwise constraint set $\set{\upsilon \sqsubseteq \upsilon' \mid \upsilon' \in V}$,
and similarly for $V \sqsubseteq \upsilon$.
\end{definition}

This is the natural representation of the constraints:
the algorithm is based on the typing rules,
and they produce constraints representing subsizing judgements that need to hold.
However, in \RecCheck and in \solve we will need to view these constraints as a graph.
We use $C$ to represent either the constraint set or the graph depending on the context.
First, notice that any noninfinite size consists of a size variable and some concrete number $n$ of successor ``hats'';
we will write this as $\succ{\upsilon}^n$ so that, for instance, $\succ{\succ{\succ{\upsilon}}}$ is instead $\succ{\upsilon}^3$.

\begin{definition}
A \textbf{subsizing constraint graph} (or simply \textbf{constraint graph}) $C$ of a constraint set is a weighted, directed graph whose vertices are size variables, edges are constraints, and weights are integers.

Given a constraint \mbox{$\succ{\upsilon}_1^{n_1} \sqsubseteq \succ{\upsilon}_2^{n_2}$},
the constraint graph contains an edge from $\upsilon_1$ to $\upsilon_2$ with weight $n_2 - n_1$.
Constraints of the form $s \sqsubseteq \infty$ are trivially true and aren't added to the graph.
Constraints of the form $\infty \sqsubseteq \succ{\upsilon}^n$ correspond to an edge from $\infty$ to $\upsilon$ with weight $0$.
\end{definition}

Given a constraint graph and some set of size variables $V$,
it's useful to know which variables in the graph can be reached from $V$ or will reach $V$.

\begin{definition}[Transitive closures]~\\[-4ex]
\begin{itemize}
  \item Given a set of size variables $V$, the \textbf{upward closure} $\bigsqcup V$ with respect to $C$ is the set of variables that can be reached from $V$ by travelling along the directed edges of $C$.
  That is, $V \subseteq \bigsqcup V$, and if $\upsilon_1 \in \bigsqcup V$ and $\succ{\upsilon}_1^{n_1} \sqsubseteq \succ{\upsilon}_2^{n_2}$, then $\upsilon_2 \in \bigsqcup V$.
  \item Given a set of size variables $V$, the \textbf{downward closure} $\bigsqcap V$ with respect to $C$ is the set of variables that can reach $V$ by travelling along the directed edges of $C$.
  That is, $V \subseteq \bigsqcap V$, and if $\upsilon_2 \in \bigsqcap V$ and $\succ{\upsilon}_1^{n_1} \sqsubseteq \succ{\upsilon}_2^{n_2}$, then $\upsilon_1 \in \bigsqcap V$.
\end{itemize}
\end{definition}

Finally, we can define what it means to be a solution of a constraint set,
as well as some useful related notation.

\begin{definition}[Size substitutions and constraint satisfaction]~\\[-4ex]
\begin{itemize}
  \item A size substitution $\rho$ applied to a set of size variables produces a set of size expressions:
  $\rho V \coloneqq \set{\rho \upsilon \mid \upsilon \in V}$.
  Applying $\rho$ to a constraint set works similarly.

  \item The composition of size substitutions $\rho_1$ and $\rho_2$ is defined as \mbox{$(\rho_1 \circ \rho_2) \upsilon \coloneqq \rho_1(\rho_2 \upsilon)$}.

  \item A size substitution $\rho$ \textbf{satisfies the constraint set} $C$ (or is a \textbf{solution} of $C$), written as $\rho \vDash C$, if for every constraint $s_1 \sqsubseteq s_2$ in $C$, the judgement $\rho s_1 \sqsubseteq \rho s_2$ holds.
\end{itemize}
\end{definition}

\input{figures/contexts-gen.tex}

Solutions of constraint sets are used when inferring sizes of global declarations.
The constraint sets are generated when inferring sizes of terms.
Each use of a definition must assign fresh size variables to its body; therefore, we must also propagate the constraints that enforce subsizing relations between those size variables.
To this end, we introduce \emph{generic}%
\footnote{This terminology is borrowed from \citet{universes}, who have similar environments in the context of universe level constraint collection in the presence of cumulativity.}
environments in \autoref{fig:contexts-gen}, where definitions are associated with a constraint set.
Given a generic local environment $\Psi$, we write $\Gamma_{\Psi}$ to mean the local environment corresponding to $\Psi$ without its constraint sets.
% [This isn't ever used?] As usual, we will use $\Psi$ as shorthand for sized generic environments and $\Psi^\circ$ for bare generic environments.
% By abuse of notation, we treat $\Psi(\ph)$ and $\Gamma_G(\ph)$ as lookup functions for $\Psi$ and $\Gamma_G$, where $\Psi(x) = t$ if $(x : t) \in \Psi$ and $\Psi(x) = (C, e : t)$ if $(C, x : t \coloneqq e) \in \Psi$, and similarly for $\Gamma_G$.

We now define four judgements to represent \emph{algorithmic subtyping}, \emph{checking}, \emph{inference}, and \emph{well-formed\-ness}.
They all use the symbol $\rightsquigarrow$, with inputs on the left and outputs on the right.
\begin{itemize}
  \item $\Gamma_G, \Gamma \vdash t \constrain u \rightsquigarrow C$ (algorithmic subtyping) takes environments $\Gamma_G, \Gamma$ and annotated terms $t, u$, and produces a set of constraints $C$ that must be satisfied in order for $t$ to be a subtype of $u$.
  \item $\gp \vdash e^\circ \Leftarrow t \rightsquigarrow C, e$ (checking) takes environments $\Gamma_G, \Psi$, a bare term $e^\circ$, and an annotated type $t$, and produces the annotated term $e$ with a set of constraints $C$ that ensures that the type of $e$ subtypes $t$.
  \item $\gp \vdash e^\circ \rightsquigarrow C', e \Rightarrow t$ (inference) takes environments $\Gamma_G, \Psi$, and a bare term $e^\circ$, and produces the annotated term $e$, its annotated type $t$, and a set of constraints $C$.
  \item $\Gamma_G^\circ \rightsquigarrow \Gamma_G$ (well-formedness) takes a global environment with bare declarations and produces a global environment where each declaration has been properly annotated via size inference.
\end{itemize}

The algorithm is implicitly parameterized over a fixed signature $\Sigma$,
as well as two mutable sets of size variables $\V, \V^*$, such that $\V^* \subseteq \V$.
Their assignment is denoted with $\coloneqq$ and they are initialized as empty.
The set $\V^*$ contains \textit{position} size variables,
which mark size-preserving types by replacing position annotations,
and we use $\tau$ for these position size variables.
We define two related metafunctions: \PV returns all position size variables in a given term,
while $\erase{\ph}^*$ erases position size variables to position annotations and all other annotations to bare.
Finally, on the right-hand size of inference judgements, we use $e \Rightarrow^* t$ to mean $e \Rightarrow t' \wedge t = \whnf{t'}$.

We define a number of additional metafunctions to translate the side conditions from the typing rules into procedural form.
They are introduced as needed, but are also summarized in \autoref{fig:inference-metafunctions} in \autoref{sec:supplementary}.

\paragraph*{} The entry point of the algorithm is the well-formedness judgement,
whose rules are defined in \autoref{fig:algorithm-wf} and use the mutually-defined rules of the checking and inference judgements,
defined in \autoref{fig:algorithm-check} and \autoref{fig:algorithm} respectively.
We begin with the latter two first in \autoref{subsec:algorithm:infer},
followed by a detailed look at \RecCheck in \autoref{subsec:algorithm:reccheck}.
Well-formedness is discussed in \autoref{subsec:algorithm:wf}.
Finally, we make our way up to soundness and completeness with respect to the typing rules in \autoref{subsec:algorithm:metatheory}.

\subsection{Inference Algorithm}\label{subsec:algorithm:infer}

Size inference begins with either a bare term or a position term. For the bare terms, even type annotations of \cofixpoints are bare, \ie
  $$e^\circ \Coloneqq \dots
    \mid \fix{m}{f^n}{t^\circ}{e^\circ}
    \mid \cofix{m}{f}{t^\circ}{e^\circ}$$
Notice that fixpoints still have the indices $n$ of the recursive arguments, whereas surface Coq programs generally have no indices.
To produce these indices, we do what Coq currently does: brute-force search.
We try the algorithm on every combination of indices from left to right.
This continues until one combination works, or fails if none do.
Then the type annotations are initially position-annotated on as many types as possible,
and this position term itself is passed into the algorithm.
Because of the way the Coq kernel is structured, this may not always be possible in the implementation.
We discuss this and other implementational issues in the next section.

\input{figures/algorithm-subtyping.tex}
\input{figures/algorithm-check.tex}
\input{figures/algorithm.tex}

\paragraph*{} \refrule{a-check} in \autoref{fig:algorithm-check} is the checking component of the algorithm.
It uses algorithmic subtyping in \autoref{fig:algorithm-subtyping} to ensure that the inferred type of the term is a subtype of given type.
This subtyping is defined inductively over the rules of the subtyping judgement in the straightforward manner, taking the union of constraint sets from their premises;
we present only Rules \refnorule{a-st-ind} and \refnorule{a-st-coind},
which shows the concrete subsizing constraints derived from comparing two \coinductive types.
It may also fail if two terms are not subtypes and are inconvertible.

\autoref{fig:algorithm} is the inference component of the algorithm. Rules \refnorule{a-var-assum}, \refnorule{a-const-assum}, \refnorule{a-univ}, \refnorule{a-prod}, \refnorule{a-abs}, and \refnorule{a-app} are all fairly straightforward.
Note that after type annotations pass through inference to become sized types, they must be erased to bare types again.
These rules use the metafunctions \axiom, \rules, and \elim, which correspond to the sets \Axioms, \Rules, and \Elims, defined in \autoref{fig:axruel}.
The metafunction \axiom produces the type of a universe; \rules produces the type of a function type given the universes of its argument and return types; and \elim directly checks membership in \Elims and can fail.

\refrule{a-let-in} is also straightforward.
After checking the bound term against the inferred type, we add the generated constraint to the generic local environment before inferring the type of the body.
If size variables appear in the bound term or its type, then the subsizing relations among them are maintained by these constraints.
Note that there may be relations between the size variables in the term and those in the type, which is why, when using variables with definitions, we need to simultaneously replace the size variables in both the term \textit{and} the type.
For instance, consider the following inductive type and bare let expression:
\begin{align*}
  \app{\Box}{(\assm{A}{\Type{}})} : A \to \Type{} &\coloneqq
  \MkBox : (\assm{a}{A}) \to \app{\Box}{A}{a} \\
  \letin{b}{\app{\Box}{\Type{}}{\Nat}&}{\app{\MkBox}{\Type{}}{\Nat}}{\dots}
\end{align*}

If we annotate the type as $\app{\Box^{\upsilon_1}}{\Type{}}{\Nat^{\upsilon_2}}$ and size-infer the bound term as $\app{\MkBox}{\Type{}}{\Nat^{\upsilon_3}} : \app{\Box^{\upsilon_4}}{\Type{}}{\Nat^{\upsilon_3}}$, then we will have the constraint set \mbox{$\set{\upsilon_4 \sqsubseteq \upsilon_1, \upsilon_2 = \upsilon_3}$}.

In Rules \refnorule{a-var-def} and \refnorule{a-const-def},
we annotate variables and constants with a size substitution mapping size variables in the definition term and type to fresh size variables using \fresh,
which generates the given number of variables and adds them to $\V$.
Reusing the above example, if
$$(\set{\upsilon_4 \sqsubseteq \upsilon_1, \upsilon_2 = \upsilon_3}, \defn{b}{\app{\Box^{\upsilon_1}}{\Type{}}{\Nat^{\upsilon_2}}}{\app{\MkBox}{\Type{}}{\Nat^{\upsilon_3}}}) \in \Psi$$
then a use of $b$ might be annotated as $b^{\seq{\upsilon_1 \mapsto \upsilon_5, \upsilon_2 \mapsto \upsilon_6, \upsilon_3 \mapsto \upsilon_7}}$.
Furthermore, the constraint set we return will include $\set{\upsilon_4 \sqsubseteq \upsilon_5, \upsilon_6 = \upsilon_7}$.
If $b$ is $\delta$\=/reduced during inference, such as in a fixpoint type, then it is replaced by $\app{\MkBox}{\Type{}}{\Nat^{\upsilon_7}}$.

A position term from a position-annotated \cofixpoint type can be passed into the algorithm, so we deal with the possibilities separately in Rules \refnorule{a-ind} and \refnorule{a-ind-star}.
In both rules, a bare \coinductive type is annotated with a size variable; in \refrule{a-ind-star}, it is also added to the set of position size variables $\V^*$.
The position annotation of \coinductive types occurs in \refrule{a-fix} or \refrule{a-cofix}, which we discuss shortly.

In \refrule{a-constr}, we generate a single fresh size variable, which gets annotated on the constructor's \coinductive type in the argument types of the constructor type, as well as the return type, which has the successor of that size variable.
All other \coinductive types which are not the constructor's \coinductive type continue to have $\infty$ annotations.

The key constraint in \refrule{a-case} is generated by \casesize.
Similar to \refrule{a-constr}, we generate a single fresh size variable $\upsilon$ to annotate on $I_k$ in the branches' argument types, which correspond to the constructor arguments of the target.
Then, given the unapplied target type $I_k^s$, \casesize returns $\set{s \sqsubseteq \hat{\upsilon}}$ if $I_k$ is inductive and $\set{\hat{\upsilon} \sqsubseteq s}$ if $I_k$ is coinductive.
This ensures that the target type satisfies $I_k^s ~ \overline{p} ~ \overline{a} \leq I_k^{\hat{\upsilon}_k} ~ \overline{p} ~ \overline{a}$, so that \refrule{case} is satisfied.

The rest of the rule proceeds as we would expect: we infer the sized type of the target and the motive, we check that the motive and the branches have the types we expect given the target type, and we infer that the sized type of the case expression is the annotated motive applied to the target type's annotated indices and the annotated target itself.
We also ensure that the elimination universes are valid using \elim on the motive type's return universe and the target type's universe.
To obtain the motive type's return universe, we use \decompose.
Given a type $t$ and a natural $n$, this metafunction reduces $t$ to a function type $\prodctx{\Delta}{u}$ where $\norm{\Delta} = n$, reduces $u$ to a universe $U$, and returns $U$.
It can fail if $t$ cannot be reduced to a function type, if $\norm{\Delta} < n$, or if $u$ cannot be reduced to a universe.

\paragraph*{} Finally, we come to size inference and termination/productivity checking for \cofixpoints.
It uses the following metafunctions:
\begin{itemize}
  \item \setrecstars, given a function type $t$ and an index $n$, decomposes $t$ into arguments and a return type, reduces the $n$th argument type to an inductive type, annotates that inductive type with position annotation $*$, annotates the return type with $*$ if it has the same inductive type, and rebuilds the function type.
    This is how fixpoint types obtain their position annotations without being user-provided; the algorithm will remove other position annotations if size-preservation fails.
    
    Similarly, \setcorecstars annotates the coinductive return type first, then the argument types with the same coinductive type.
    Both of these can fail if the $n$th argument type or the return type respectively are not \coinductive types.
    Note that the decomposition of $t$ may perform reductions using \whnf.
  \item \getrecvar, given a function type $t$ and an index $n$, returns the position size variable of the annotation on the $n$th inductive argument type, while \getcorecvar returns the position size variable of the annotation on the coinductive return type.
    Essentially, they retrieve the position size variable of the annotation on the primary \corecursive type of a \cofixpoint type.
  \item \shift replaces all position size annotations $s$ (\ie $\floor{s} \in \V^*$) by its successor $\hat{s}$.
\end{itemize}

Although the desired \cofixpoint is the $m$th one in the block of mutually-defined \cofixpoints, we must still size-infer and type-check the entire mutual definition.
Rules \refnorule{a-fix} and \refnorule{a-cofix} first run the size inference algorithm on each of the \cofixpoint \emph{types}, ignoring the results, to ensure that any reduction on those types will terminate.
Then we annotate the bare types with position annotations (using \setrecstars/\setcorecstars) and pass these position types through the algorithm to get sized types $\overline{t_k}$.
Next, we check that the \cofixpoint bodies have the successor-sized types of $\overline{t_k}$ when the \cofixpoints have types $\overline{t_k}$ in the local environment.
Lastly, we call \RecCheckLoop, and return the constraints it gives us, along with the $m$th \cofixpoint type.

\input{figures/helpers.tex}

Notice that \setrecstars and \setcorecstars optimistically annotate \textit{all} possible \coinductive types in the \cofixpoint type with position annotations, but not all \cofixpoints are size-preserving.
\RecCheckLoop filters these annotations to generate the final constraint set.
This is a recursive function that calls \RecCheck, which checks satisfiability of a given constraint set.
If the set is unsatisfiable due to a bad position annotation, then \RecCheckLoop removes the annotation and tries again.

More specifically, \RecCheck can fail raising \RecCheckFail, which contains a set $V$ of position size variables that must be set to infinity; since position size variables always appear on size-preserved types, they cannot be infinite.
\RecCheckLoop then removes $V$ from the set of position size variables, allowing them to be set to infinity, and recursively calls itself.
The number of position size variables from the \cofixpoint type shrinks on every iteration until no more can be removed.
If no satisfiable set is found even when no positions are considered size preserving, termination/productivity checking and thus type inference has failed.
An OCaml-like pseudocode implementation of \RecCheckLoop is provided by \autoref{fig:helpers}.

\subsection{RecCheck}\label{subsec:algorithm:reccheck}

As in previous work on \CChatomega with coinductive streams~\citep{cc-hat-omega} and in \CIChat, we use the same \RecCheck algorithm from \Fhat~\citep{f-hat}.
This algorithm attempts to ensure that the subsizing rules in \autoref{fig:subsizing} can be satisfied within a given set of constraints.
It does so by checking the set of constraints for invalid circular subsizing relations, setting the size variables involved in the cycles to $\infty$, and producing a new set of constraints without these problems; or it fails, indicating nontermination or nonproductivity.
It takes four arguments:

\begin{itemize}
  \item A constraint set $C$, which we treat as a constraint graph.
  \item The size variable $\tau$ of the annotation on the type of the recursive argument (for fixpoints) or on the return type (for cofixpoints). While the return type (for fixpoints) or the types of other arguments (for cofixpoints) may optionally be marked as size-preserving, each \cofixpoint type requires at \textit{least} $\tau$ for the primary \corecursive type.
  \item A set of size variables $V^*$ that must be set to some non-infinite size.
    These are the size annotations in the \cofixpoint type that have position size variables.
    Note that $\tau \in V^*$.
  \item A set of size variables $V^\neq$ that must be set to $\infty$.
    These are all other non-position size annotations, found in the \cofixpoint types and bodies.
\end{itemize}

The key idea of the algorithm is that if there is a negative cycle in $C$,
then for any size variable $\upsilon$ in the cycle,
supposing that the total weight going once around the cycle is $-n$,
by transitivity we have the subsizing relation $\succ{\upsilon}^{n} \sqsubseteq \upsilon$,
This relation can only hold if $\upsilon = \infty$,
since $\succ{\infty} \sqsubseteq \infty$.
The algorithm proceeds as follows:

\begin{enumerate}
  \item \label{item:reccheck:smallest} Let $V^\iota = \bigsqcap V^*$, and add $\tau \sqsubseteq V^\iota$ to $C$.
    This ensures that $\tau$ is the smallest size variable among all the noninfinite size variables.
  \item \label{item:reccheck:neg-cycles} Find all negative cycles in $C$, and let $V^-$ be the set of all size variables in some negative cycle.
  \item Remove all edges with size variables in $V^-$ from $C$, and add $\infty \sqsubseteq V^-$.
  \item \label{item:reccheck:infty} Add $\infty \sqsubseteq \left(\bigsqcup V^\neq \cap \bigsqcup V^\iota\right)$ to $C$.
  \item \label{item:reccheck:bot} Let $V^\bot = \left(\bigsqcup \set{\infty}\right) \cap V^\iota$.
    This is the set of size variables that we have determined to both be infinite and noninfinite.
    If $V^\bot$ is empty, then return $C$.
  \item \label{item:reccheck:fail} Otherwise, let $V = V^\bot \cap (V^* \setminus \set{\tau})$, and fail with $\RecCheckFail{V}$.
    This is the set of contradictory position size variables excluding $\tau$, which we can remove from $\V^*$ in \RecCheckLoop.
    If $V$ is empty, there are no position size variables left to remove, so the check and therefore the size inference algorithm fails.
\end{enumerate}

Disregarding closure operations and set operations like intersection and difference, the time complexity of a single pass is $O(\norm{V}\norm{C})$, where $V$ is the set of size variables appearing in $C$.
This comes from the negative-cycle finding in (\ref{item:reccheck:neg-cycles}) using, for instance, the Bellman--Ford algorithm.

\input{figures/algorithm-wf.tex}

\subsection{Well-Formedness}\label{subsec:algorithm:wf}

A self-contained chunk of code, be it a file or a module, consists of a sequence of \coinductive definitions (signatures) and programs (global declarations).
For our purposes, we assume that there is a singular well-formed signature defined independently.
Then we need to perform size inference on each declaration of $\Gamma_G$ in order.
This is given by Rules \refnorule{a-global-nil}, \refnorule{a-global-assum}, and \refnorule{a-global-def} in \autoref{fig:algorithm-wf}.

In \refrule{a-global-def}, the \solve metafunction takes the constraint set $C_1 \cup C_2$ and produces a size substitution that, when applied to the annotated term and type, ensures that they form a well-typed judgement. In otherwords, we are guaranteed that $\Sigma, \Gamma_G, \mt \vdash \rho e : \rho t$ holds.

Assuming for now that the corresponding constraint graph has no negative cycles, for every connected component, we want to assign each size variable the same common size variable but with a different size.
For instance, given the constraint set $\set{\upsilon_1 \sqsubseteq \hat{\upsilon}_2, \hat{\upsilon_1} \sqsubseteq \upsilon_3}$, a possible solution would be the mapping $\set{\upsilon_1 \mapsto \tau, \upsilon_2 \mapsto \upsilon^*, \upsilon_3 \mapsto \hat{\tau}}$.

This kind of problem is a \emph{difference constraint} problem \citep{clrs}.
Generally a solution involves finding a mapping from variables to integers, whereas our solution will map from size variables to size expressions with the same base, but the technique using a single-source shortest-path algorithm still applies.
Given a connected component $C_c$ with no negative cycles or an $\infty$ vertex, our algorithm $\solvecomp$ for finding a solution proceeds as follows:

\begin{enumerate}
  \item Generate a fresh size variable $\tau$.
  \item For every size variable $\upsilon_i$ in $C_c$, add an edge $\tau \sqsubseteq \upsilon_i$ of weight $0$.
  \item \label{item:solvecomp:shortest-path} Find the weights $w_i$ of the shortest paths from $\tau$ to every other size variable $\upsilon_i$ in $C_c$.
    This yields the constraint $\tau \sqsubseteq \hat{\upsilon}_i^{w_i}$.
  \item Na\"ively, we would map each $\upsilon_i$ to the size expression $\hat{\tau}^{-w_i}$.
    However, $-w_i$ may be negative, which would make no sense as the size of a size variable.
    Therefore, we find the largest weight $w_{\max} \coloneqq \max_i w_i$, and shift all the sizes up by $w_{\max}$.
    In other words, we return the map $\rho \coloneqq \set{\upsilon_i \mapsto \hat{\tau}^{w_{\max} - w_i}}$.
\end{enumerate}

Again, the time complexity of a single pass is $O(\norm{V}\norm{C_c})$ (where $V$ is the set of size variables in $C_c$)
due to
finding the single-source shortest paths in (\ref{item:solvecomp:shortest-path}) using,
for instance, the Bellman--Ford algorithm.
(Note that although there are no negative cycles, there are still negative \emph{weights}, so we cannot use, for example, Dijkstra's algorithm.)
The total $\solve$ algorithm, given some constraint graph $C$, is then as follows:

% Is removing negative cycles necessary? Could we prove that there are *no* negative cycles?
\begin{enumerate}
  \item Initialize an empty size substitution $\rho$.
  \item Find all negative cycles in $C$, and let $V^-$ be all size variables in some negative cycle.
  \item Let $V^\infty = \bigsqcup \set{\infty}$.
  \item Remove all edges with size variables in $V^- \cup V^\infty$ from $C$, and for every $\upsilon_i \in V^- \cup V^\infty$, add $\upsilon_i \mapsto \infty$ to $\rho$.
  \item For every connected component $C_c$ of $C$, add mappings $\solvecomp{C_c}$ to $\rho$.
\end{enumerate}

Since dividing the constraint graph into connected components partitions the size variables and constraints into disjoint sets,
the time complexity of all executions of \solvecomp is $O(\norm{V}\norm{C})$.
This is also the time complexity of negative-cycle finding.
These two dominate the time complexity of finding the connected components,
which is $O(\norm{V} + \norm{C})$.

The resulting size substitution $\rho$ will then satisfy $\rho \vDash C$.
As we will see in the following subsection,
with soundness this implies that $\Sigma, \Gamma_G, \mt \vdash \rho e : \rho t$ holds.

\subsection{Metatheory}\label{subsec:algorithm:metatheory}

In this subsection, we focus on soundness and completeness theorems of various parts of the inference algorithm.
We first need soundness and completeness of \RecCheck.
We reproduce part of their proofs here,
and refer the reader to \citet{f-hat} for further details.

Intuitively, soundness says that if you have a solution to a constraint set returned by \RecCheck,
then there must also be a solution to the original constraint set satisfying some important properties.
Dually, completness says that if you have a solution to the original constraint set satisfying these properties, then it must also be a solution to the constraint set returned by \RecCheck.

\begin{theorem}[Soundness of \RecCheck (SRC)]\label{thm:src}
If $\RecCheck(C', \tau, V^*, V^\neq) = C$, for every $\rho$ such that $\rho \vDash C$,
given a fresh size variable $\upsilon$, there exists a $\rho'$ such that the following all hold:
\begin{enumerate}
  \item $\rho' \vDash C'$;
  \item $\rho'(\tau) = \upsilon$;
  \item $\floor{\rho'(V^*)} = \upsilon$;
  \item $\floor{\rho'(V^\neq)} \neq \upsilon$;
  \item For all $\upsilon' \in V^\neq$, $(\set{\upsilon \mapsto \rho(\tau)} \circ \rho')(\upsilon') = \rho(\upsilon')$; and
  \item For all $\tau' \in V^*$, $(\set{\upsilon \mapsto \rho(\tau)} \circ \rho')(\tau') \sqsubseteq \rho(\tau')$.
\end{enumerate}
\end{theorem}

\begin{proof}[{[Partial]}]
Let $C^\iota$ be $C$ with all vertices in $\bigsqcup \set{\infty}$ removed.
By the definition of \RecCheck, since all negative cycles in $C'$ are removed and the only constraints that are added are of the form $\infty \sqsubseteq s$,
$C^\iota$ has no negative cycles either.
Let $V^\iota = \bigsqcap V^*$.
Note that the constraints $\tau \sqsubseteq V^\iota$ are in $C^\iota$.
Then we are able to compute the weights $w_i$ of the shortest paths from $\tau$ to $\bigsqcup V^\iota$ with respect to $C^\iota$.
According to \citet{f-hat}, these weights are nonnegative.
Then we can define $\rho' \coloneqq \rho \circ \set{\upsilon_i \mapsto \succ{\upsilon}^{w_i} \mid \upsilon_i \in \bigsqcup V^\iota, \rho(\upsilon_i) \neq \infty}$.

\begin{enumerate}
  \item The proof is more involved; see \citet{f-hat}.
  \item The shortest path from $\tau$ to itself is no path at all, so $\rho'(\tau) = \upsilon$.
  \item Since $V^* \subseteq V^\iota \subseteq \bigsqcup V^\iota$, for every $\upsilon_i \in V^*$, $\rho'(\upsilon_i) = \succ{\upsilon}^{w_i}$ where $w_i$ is the weight of the shortest path from $\upsilon$ to $\upsilon_i$, and its size variable is obviously $\upsilon$.
  \item Let $\upsilon' \in V^\neq$. If $\upsilon' \in \bigsqcup V^\iota$, then $\infty \sqsubseteq \upsilon'$ must be in $C$, and therefore $\rho(\upsilon') = \infty$, so $\rho'(\upsilon') = \rho(\upsilon')$. Otherwise, if $\upsilon' \notin \bigsqcup V^\iota$, we again have $\rho'(\upsilon') = \rho(\upsilon')$. Since $\upsilon$ is fresh, it could not be mapped to by $\rho$, so the size variable of $\rho(\upsilon')$ cannot be $\upsilon$.
  \item Let $\upsilon' \in V^\neq$. If $\upsilon' \in \bigsqcup V^\iota$, then we must have the constraint $\infty \sqsubseteq \upsilon'$ in $C$, so $\rho(\upsilon') = \infty$. Therefore, $(\set{\upsilon \mapsto \rho(\tau)} \circ \rho')(\upsilon') = (\set{\upsilon \mapsto \rho(\tau)} \circ \rho)(\upsilon') = \rho(\upsilon')$.
  \item Let $\tau' \in V^*$. Note that $V^* \subseteq V^\iota \subseteq \bigsqcup V^\iota$.
  Then letting $w'$ be the weight of the shortest path from $\upsilon$ to $\tau'$, we have $\rho'(\tau') = \succ{\upsilon}^{w'}$, and $(\set{\upsilon \mapsto \rho(\tau)} \circ \rho')(\tau') = \succ{\rho(\tau)}^{w'}\!$.
  Since $\rho \vDash C$ and there is a path of weight $w'$ from $\tau$ to $\tau'$ in $C$,
  we have $\succ{\rho(\tau)}^{w'}\! \sqsubseteq \rho(\tau')$.
\end{enumerate}
\end{proof}

\begin{theorem}[Completeness of \RecCheck (CRC)]~\\
Suppose the following all hold:
\begin{itemize}
  \item $\rho \vDash C'$;
  \item $\rho(\tau) = \upsilon$;
  \item $\floor{\rho(V^*)} = \upsilon$; and
  \item $\floor{\rho(V^\neq)} \neq \upsilon$.
\end{itemize}
Then $\rho \vDash \RecCheck(C', \tau, V^*, V^\neq)$.
\end{theorem}

\begin{proof}
Let $C = \RecCheck(C', \tau, V^*, V^\neq)$.
To show that $\rho \vDash C$, we need to show that for every constraint $s_1 \sqsubseteq s_2$ in $C$,
$\rho(s_1) \sqsubseteq \rho(s_2)$ holds.
Since $\rho \vDash C'$, this means we need to show that $\rho$ satisfies every constraint added to $C'$ in \RecCheck.
We handle them step by step.
Let $V^\iota \coloneqq \bigsqcap V^*$, and let $V^-$ be the set of size variables involved in some negative cycle in $C'$.
\begin{itemize}
  \item \autoref{item:reccheck:smallest}: $\tau \sqsubseteq V^\iota$. Since we have $\rho(\tau) = \upsilon$ and $\rho(V^*) = \succ{\upsilon}^{n}$ for some $n$ by assumption,
  $\rho(\tau) \sqsubseteq \rho(V^\iota)$ holds.
  \item \autoref{item:reccheck:neg-cycles}: $\infty \sqsubseteq V^-$. For all size variables $\upsilon' \in V^-$,
  since being in a negative cycle transitively implies a subsizing relation $\succ{\upsilon}'^{n} \sqsubseteq \upsilon'$ for some $n$,
  the only way for $\rho(\succ{\upsilon}'^{n}) \sqsubseteq \rho(\upsilon')$ to hold is if $\rho(\upsilon') = \infty$,
  which satisfies $\infty \sqsubseteq \rho(\upsilon')$.
  \item \autoref{item:reccheck:infty}: $\infty \sqsubseteq (\bigsqcup V^\neq \cap \bigsqcup V^\iota)$. Since $\rho(V^\neq)$ and $\rho(V^\iota)$ have different size variables by assumption,
  if a size variable $\upsilon'$ is in both $\bigsqcup V^\neq$ and $\bigsqcup V^\iota$,
  it must be set to $\infty$, which satisfies $\infty \sqsubseteq \upsilon'$.
\end{itemize}
\end{proof}

\RecCheck returns a constraint set for a single \cofixpoint definition with a fixed set of position variables;
\RecCheckLoop, on the other hand, returns a constraint set for an entire mutual \cofixpoint definition, finding a suitable set of position variables.
There are then two properties we want to ensure.

\begin{theorem}[Correctness of RecCheckLoop]\label{thm:reccheckloop}~\\[-4ex]
\begin{enumerate}
  \item \RecCheckLoop terminates on all inputs.
  \item If $\RecCheckLoop{C', \Psi, \vec{\tau_k}, \vec{t_k}, \vec{e_k}} = C$ with an initial position variable set $\mathcal{V}^*$,
  then for every $i \in \vec{k}$, $\RecCheck{C', \tau_i, \PV(t_i), \SV(\Psi, t_i, e_i) \setminus \PV(t_i)} \subseteq C$ with a final position variable set $\mathcal{V}^*_\subseteq \subseteq \mathcal{V}^*$.
\end{enumerate}
\end{theorem}

\begin{proof}[{[Sketch]}]
\begin{enumerate}
  \item \RecCheckLoop does a recursive call only when \RecCheck fails with a size variable set $V$, which by definition is a subset of $\PV(t_i)$ for some $t_i$.
  Since $V$ is removed from $\mathcal{V}^*$ every time, $\PV(\vec{t_k})$ is the decreasing measure of \RecCheckLoop.
  \item Again, $\mathcal{V}^*$ is only removed from, not added to, so the final set must be a subset of the initial set.
  By inspection, $C$ is a union of the constraints returned by \RecCheck when they all succeed.
\end{enumerate}
\end{proof}

We also want to ensure that \solvecomp and \solve actually return solutions of the constraint sets they are solving.

\begin{theorem}[Correctness of \solve and \solvecomp]\label{thm:solve}~\\[-4ex]
\begin{enumerate}
  \item If the constraint set $C_c$ contains no negative cycles, then $\solvecomp{C_c} \vDash C_c$ and
  \item $\solve{C} \vDash C$.
\end{enumerate}
\end{theorem}

\begin{proof}[{[Sketch]}]
\begin{enumerate}
  \item By \citet{clrs}, any constant shift ($w_{\max}$, in our case) of a shortest-path solution is a valid solution to the difference constraint problem.
  \item By the same reasoning for \RecCheck, any variables involved in negative cycles must be set to $\infty$ in a solution.
  The remaining constraints are solved by \solvecomp.
\end{enumerate}
\end{proof}

Before proceeding onto the main soundness theorems, we first need a few lemmas.

\begin{lemma}\label{lem:posneg}
Suppose that $\rho_1(\upsilon) \sqsubseteq \rho_2(\upsilon)$.
\begin{enumerate}
  \item If $\upsilon \pos t$, then $\rho_1 t \leq \rho_2 t$; and
  \item If $\upsilon \neg t$, then $\rho_2 t \leq \rho_1 t$.
\end{enumerate}
\end{lemma}

\begin{proof}[{[Sketch]}]
By mutual induction on the positivity and negativity rules in \autoref{fig:posneg}.
\end{proof}

\begin{lemma}\label{lem:subtyping}
Let $\Gamma_G, \Gamma_{\Psi} \vdash t \constrain u \rightsquigarrow C$,
and suppose that $\rho \vDash C$.
Then $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho t \leq \rho u$.
\end{lemma}

\begin{proof}[{[Sketch]}]
By induction on the rules for algorithmic subtyping in \autoref{fig:algorithm-subtyping}.
\end{proof}

% TODO: I'm thinking of removing these few lemmas...
% \iffalse

\begin{lemma}\label{lem:constraint-subst}
$\rho \vDash \rho' C$ iff $\rho \circ \rho' \vDash C$.
\end{lemma}

\begin{proof}
\begin{align*}
  \rho \vDash \rho' C
  &\Leftrightarrow \forall s_1 \sqsubseteq s_2 \in C, \rho (\rho' s_1) \sqsubseteq \rho (\rho' s_2) \\
  &\Leftrightarrow \forall s_1 \sqsubseteq s_2 \in C, (\rho \circ \rho') s_1 \sqsubseteq (\rho \circ \rho') s_2 \\
  &\Leftrightarrow \rho \circ \rho' \vDash C
\end{align*}
\end{proof}

\begin{lemma}\label{lem:typing-subst}
  If $\gg \vdash e : t$, then $\Gamma_G, \rho \Gamma \vdash \rho e : \rho t$ and $\Gamma_G, \rho \Gamma \vdash \rho t : U$ for some $U$.
\end{lemma}

\begin{proof}[{[Sketch]}]
% TODO: Uses earlier lemma showing that $\Sigma, \Gamma_G, \subst{\Gamma}{\upsilon}{s} \vdash \subst{e}{\upsilon}{s} : \subst{t}{\upsilon}{s}.
\end{proof}

% \fi

Now we are ready to tackle the main theorems.

\begin{theorem}[Soundness (check/infer)]\label{thm:soundness}
Let $\Sigma$ be a fixed, well-formed signature, $\Gamma_G$ a global environment, and $\Psi$ a generic local environment.
Suppose we have the following:
\begin{enumerate}[label=\roman*.]
  \item \label{item:sound:wf:global} $\WF{\Gamma_G, \mt}$ holds; and
  \item \label{item:sound:psi} If $\Psi \equiv \Psi_1 (C_1, x : t \coloneqq e) \Psi_2$, then
    $\forall \rho \vDash C_1$, $\Gamma_G, \rho \Gamma_{\Psi_1} \vdash \rho e : \rho t$ holds.
\end{enumerate}
Then the following hold:
\begin{enumerate}
  \item If $\gp \vdash e^\circ \Leftarrow t \rightsquigarrow C, e$,
  then $\forall \rho \vDash C$, we have $\Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$.
  \item If $\gp \vdash e^\circ \rightsquigarrow C, e \Rightarrow t$,
  then $\forall \rho \vDash C$, we have $\Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$.
\end{enumerate}
\end{theorem}

\begin{proof}[{[Partial]}]
By mutual induction on the checking and inference rules of the algorithm.
Suppose \ref{item:sound:wf:global} and \ref{item:sound:psi} hold.
\begin{enumerate}
  \item By \refrule{a-check}, we have
  \begin{displaymath}
    \inferrule[\defrule{a-check}]{
      \gp \vdash e^\circ \rightsquigarrow C_1, e \Rightarrow t \\
      \Gamma_G, \Gamma_{\Psi} \vdash t \constrain u \rightsquigarrow C_2
    }{
      \gp \vdash e^\circ \Leftarrow u \rightsquigarrow C_1 \cup C_2, e
    }
  \end{displaymath}
  Let $\rho \vDash C_1 \cup C_2$.
  By the induction hypotheses on the premise, we have $\Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$.
  By \autoref{lem:subtyping}, we have $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho t \leq \rho u$.
  Then by \refrule{conv}, we have $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho e : \rho u$.
  \item We will prove the cases for definitions, let expressions, case expressions, and fixpoints;
  the case for cofixpoints is similar to that of fixpoints, and the remaining cases are straightforward.
  \begin{itemize}
    \item \refrule{a-var-def}.
    \begin{displaymath}
      \inferrule[]{
        (C, x : t \coloneqq e) \in \Psi \and
        \overline{\upsilon'_i} = \SV(e, t) \and
        \overline{\upsilon_i} = \fresh{\norm{\overline{\upsilon'_i}}} \and
        \rho = \set{\vec{\upsilon'_i \mapsto \upsilon_i}}
      }{
        \gp \vdash x \rightsquigarrow \rho C, x^\rho \Rightarrow \rho t
      }
    \end{displaymath}
    Let $\rho' \vDash C$.
    We must show that $\Gamma_G, \rho' \Gamma_{\Psi} \vdash \rho' x^\rho : \rho' (\rho t)$ holds.
    % TODO.
    \item \refrule{a-const-def}.
    \begin{displaymath}
      \inferrule[]{
        (\defn{x}{t}{e}) \in \Gamma_G \and
        \overline{\upsilon'_i} = \SV(e, t) \and
        \overline{\upsilon_i} = \fresh{\norm{\overline{\upsilon'_i}}} \and
        \rho = \set{\vec{\upsilon'_i \mapsto \upsilon_i}}
      }{
        \gp \vdash x \rightsquigarrow \set{}, x^\rho \Rightarrow \rho t
      }
    \end{displaymath}
    Since the constraint set is empty, we must simply show that $\Gamma_G, \Gamma_{\Psi} \vdash x^\rho : (\rho t)$ holds.
    % TODO.
    \item \refrule{a-let-in}.
    \begin{displaymath}
      \inferrule[]{
        \gp \vdash t^\circ \rightsquigarrow C_1, t \Rightarrow^* U \\
        \gp \vdash e_1^\circ \Leftarrow t \rightsquigarrow C_2, e_1 \\
        \gp (C_1 \cup C_2, x:t \coloneqq e_1) \vdash e_2^\circ \rightsquigarrow C_3, e_2 \Rightarrow u
      }{
        \gp \vdash \letin{x}{t^\circ}{e_1^\circ}{e_2^\circ} \rightsquigarrow C_1 \cup C_2 \cup C_3, \letin{x}{|t|}{e_1}{e_2} \Rightarrow u[x \coloneqq e_1]
      }
    \end{displaymath}
    Let $\rho \vDash C_1 \cup C_2 \cup C_3$.
    We must show that $\Gamma_G, \Gamma_{\Psi} \vdash \rho (\letin{x}{|t|}{e_1}{e_2}) : \rho (u[x \coloneqq e_1])$.
    The induction hypotheses on the premises tell us the following:
    \begin{itemize}
      \item $\forall \rho_1 \vDash C_1, \Gamma_G, \rho_1 \Gamma_{\Psi} \vdash \rho_1 t : U$;
      \item $\forall \rho_2 \vDash C_2, \Gamma_G, \rho_2 \Gamma_{\Psi} \vdash \rho_2 e_1 : \rho_2 t$; and
      \item $\forall \rho_3 \vDash C_3, \Gamma_G, \rho_3 (\Gamma_{\Psi}(\defn{x}{t}{e_1})) \vdash \rho_3 e_2 : \rho_3 u$.
    \end{itemize}
    Applying $\rho$ to all three and using \refrule{let} yields our goal.
    \item \refrule{a-case}.
      \begin{displaymath}
      \inferrule[]{
        \gp \vdash e^\circ \rightsquigarrow C_1, e \Rightarrow^* \app{I_k^s}{\vec{p}}{\vec{a}} \\
        \gp \vdash P^\circ \rightsquigarrow C_2, P \Rightarrow t_p \\
        \prodctx{\any}{\prodctx{\Delta_k}{U_k}} = \indtype{I_k} \\
        U = \decompose{t_p}{\norm{\Delta_k} + 1} \\
        \elim{U_k}{U}{I_k} \\
        \upsilon = \fresh{1} \\
        \Gamma_G, \Gamma_{\Psi} \vdash t_p \constrain \motivetype{\overline{p}}{U}{I_k^{\hat{\upsilon}}} \rightsquigarrow C_3 \\
        \textrm{For each $j$:} \\
        \Gamma_G, \Psi \vdash e^\circ_j \Leftarrow \branchtype{\overline{p}}{c_j}{\upsilon}{P} \rightsquigarrow C_{4j}, e_j \\
        C = \casesize{I_k^s}{\hat{\upsilon}} \cup C_1 \cup C_2 \cup C_3 \cup (\textstyle\bigcup_j C_{4j})
      }{
        \gp \vdash \caseof{P^\circ}{e^\circ}{c_j}{e_j^\circ} \rightsquigarrow C, \caseof{|P|}{e}{c_j}{e_j} \Rightarrow \app{P}{\vec{a}}{e}
      }
      \end{displaymath}
      Let $\rho \vDash C$.
      We must show that $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho (\caseof{|P|}{e}{c_j}{e_j}) : \rho (\app{P}{\vec{a}}{e})$.
      The induction hypotheses and \autoref{lem:subtyping} tell us the following:
      \begin{itemize}
        \item $\forall \rho_1 \vDash C_1, \Gamma_G, \rho_1 \Gamma_{\Psi} \vdash \rho_1 e : \rho_1 (\app{I^s_k}{\vec{p}}{\vec{a}})$;
        \item $\forall \rho_2 \vDash C_2, \Gamma_G, \rho_2 \Gamma_{\Psi} \vdash \rho_2 P : \rho_2 t_p$;
        \item $\forall \rho_3 \vDash C_3, \Gamma_G, \rho_3 \Gamma_{\Psi} \vdash \rho_3 t_p \leq \rho_3 (\motivetype{\vec{p}}{U}{I_k^{\hat{\upsilon}}})$; and
        \item $\forall \rho_{4j} \vDash C_{4j}, \Gamma_G, \rho_{4j} \Gamma_{\Psi} \vdash \rho_{4j} e_j : \rho_{4j} (\branchtype{\vec{p}}{c_j}{\upsilon}{P})$.
      \end{itemize}
      We can apply $\rho$ to all four of these.
      By \refrule{conv}, we have that $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho P : \rho (\motivetype{\vec{p}}{U}{I_k^{\hat{\upsilon}}})$.
      Because $\rho \vDash \casesize{I_k^s, \hat{\upsilon}}$,
      $\rho s \sqsubseteq \rho \hat{\upsilon}$ if $I_k$ is inductive and
      $\rho \hat{\upsilon} \sqsubseteq s$ if $I_k$ is coinductive.
      Then by Rules \refnorule{st-ind} or \refnorule{st-coind} respectively,
      we have $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho I_k^s \leq \rho I_k^{\hat{\upsilon}}$,
      and by \refrule{conv}, we have $\forall \rho_1 \vDash C_1, \Gamma_G, \rho_1 \Gamma_{\Psi} \vdash \rho_1 e : \rho_1 (\app{I_k^{\hat{\upsilon}}}{\vec{p}}{\vec{a}})$.
      Finally, using \refrule{case}, we have our goal.
    \item \refrule{a-fix}.
      \begin{displaymath}
        \inferrule[\defrule{a-fix}]{
          \textrm{For each $k$:} \\
          \gp \vdash t_k^\circ \rightsquigarrow \any, \any \Rightarrow \any \\
          \gp \vdash \setrecstars{t_k^\circ}{n_k} \rightsquigarrow C_{1k}, t_k \Rightarrow^* U \\
          \prodctx{\Delta_k}{u_k} = \whnf{t_k} \and \prodctx{\Delta_k}{u'_k} = \shift{\prodctx{\Delta_k}{u_k}} \\
          \gp \overline{(f_k : t_k)} \vdash e_k^\circ \Leftarrow \prodctx{\Delta_k}{u'_k} \rightsquigarrow C_{2k}, e_k \\
          \Gamma_G, \Gamma_{\Psi} \Delta_k \vdash u_k \constrain u'_k \rightsquigarrow C_{3k} \\
          C_4 = \textstyle\bigcup_k C_{1k} \cup C_{2k} \cup C_{3k} \\
          C_5 = \RecCheckLoop{C_4}{\overline{\getrecvar{t_k}{n_k}}}{\overline{t_k}}{\overline{e_k}}
        }{
          \gp \vdash \fix{m}{f_k^{n_k}}{t_k^\circ}{e_k^\circ} \rightsquigarrow C_5, \fix{m}{f_k^{n_k}}{|t_k|^*}{e_k} \Rightarrow t_m
        }
      \end{displaymath}
      Let $\rho \vDash C_5$.
      We must show that $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho (\fix{m}{f_k^{n_k}}{|t_k|^*}{e_k}) : \rho t_m$.
      The induction hypotheses tell us the following:
      \begin{itemize}
        \item $\forall \rho_{1k} \vDash C_{1k}, \Gamma_G, \rho_{1k} \Gamma_{\Psi} \vdash \rho_{1k} t_k : U$;
        \item $\forall \rho_{2k} \vDash C_{2k}, \Gamma_G, \rho_{2k} (\Gamma_{\Psi} \vec{(f_k : t_k)}) \vdash \rho_{2k} e_k : \rho_{2k} (\prodctx{\Delta_k}{u'_k})$; and
        \item $\forall \rho_{3k} \vDash C_{3k}, \Gamma_G, \rho_{3k} (\Gamma_{\Psi} \Delta_k) \vdash \rho_{3k} u_k \leq \rho_{3k} u'_k$.
      \end{itemize}
      By \autoref{thm:reccheckloop}, from $\rho \vDash C_5$,
      we also have that for every $i \in \vec{k}$,
      $\rho \vDash \RecCheck{C_4, \tau_i, \PV{t_i}, \SV{\Psi, t_i, e_i} \setminus \PV{t_i}}$,
      where $\tau_i = \getrecvar{t_i, n_i}$.
      Then applying \autoref{thm:src}, letting $\upsilon_i$ be a fresh size variable, there exists a $\rho'$ such that the following hold:
      \begin{enumerate}
        \item \label{item:soundness:fix:1} $\rho' \vDash C_4$;
        \item \label{item:soundness:fix:2} $\rho' \tau_i = \upsilon_i$
        \item \label{item:soundness:fix:3} $\floor{\rho' \PV{t_i}} = \upsilon_i$
        \item \label{item:soundness:fix:4} $\floor{\rho' (\SV{\Psi, t_i, e_i} \setminus \PV{t_i})} \neq \upsilon_i$;
        \item \label{item:soundness:fix:5} $\forall \upsilon' \in \SV{\Psi, t_i, e_i} \setminus \PV{t_i}, (\set{\upsilon_i \mapsto \rho \tau} \circ \rho') \upsilon' = \rho \upsilon'$; and
        \item \label{item:soundness:fix:6} $\forall \tau' \in \PV{t_i}, (\set{\upsilon_i \mapsto \rho \tau} \circ \rho') \tau' \sqsubseteq \rho \tau'$.
      \end{enumerate}
      By \ref{item:soundness:fix:4} and \ref{item:soundness:fix:5} together, we can conclude that 
      $\forall \upsilon' \in \SV{\Psi, t_i, e_i} \setminus \PV{t_i}, \rho' \upsilon' = \rho \upsilon'$, so $\rho'\Psi = \rho \Psi$ and $\rho' e_k = \rho e_k$.
      Then by \ref{item:soundness:fix:1}, we can apply $\rho'$ to each the inductive hypotheses and simplify to yield:
      \begin{itemize}
        \item $\Gamma_G, \rho \Gamma_{\Psi} \vdash \rho' t_k : U$;
        \item $\Gamma_G, (\rho \Gamma_{\Psi})\vec{(f_k : \rho' t_k)} \vdash \rho e_k : \rho' (\prodctx{\Delta_k}{u'_k})$; and
        \item $\Gamma_G, (\rho \Gamma_{\Psi})(\rho'\Delta_k) \vdash \rho' u_k \leq \rho' u'_k$.
      \end{itemize}
      Notice that \shift only shifts position variables up by one, which means that by \ref{item:soundness:fix:2}, $\rho'u'_k = \set{\upsilon_i \mapsto \succ{\upsilon}_i}(\rho'u_k)$.
      Then by \autoref{lem:posneg} applied to the empty substitution and $\set{\upsilon_i \mapsto \succ{\upsilon}_i}$, the last subtyping judgement implies that $\upsilon_i \pos \rho'u_k$.
      At last, we are able to apply \refrule{fix}, picking $s = \upsilon_m$:
      $$\Gamma_G, \rho \Gamma_{\Psi} \vdash \fix{m}{f_k^{n_k}}{|\rho' t_k|^{\upsilon_k}}{\rho e_k} : \rho' t_m$$
      By \ref{item:soundness:fix:3} and \ref{item:soundness:fix:4}, we have $\erase{\rho' t_i}^{\upsilon_i} = \erase{t_i}^*$.
      Finally, % TODO: Apply \ref{item:soundness:fix:6}.
  \end{itemize}
\end{enumerate}
\end{proof}

\begin{conjecture}[Completeness (check/infer)]
Let $\Sigma$ be a fixed, well-formed signature, $\Gamma_G$ a global environment, $\Psi$ a generic local environment, $C$ a constraint set, and $\rho \vDash C$ a solution to the constraint set.
Then the following hold:
\begin{enumerate}
  \item If $\Gamma_G, \rho\Gamma_{\Psi} \vdash e : \rho t$,
    then there exist $C', \rho'$ such that:
    \begin{itemize}
      \item $\rho' \vDash C'$;
      \item $\forall \upsilon \in \SV(\Gamma_{\Psi}, t), \rho \upsilon = \rho' \upsilon$; and
      \item $C, \Gamma_G, \Psi \vdash \erase{e} \Leftarrow t \rightsquigarrow C', e'$ where $\Gamma_G, \Gamma_{\Psi} \vdash \rho' e' \conv e$.
    \end{itemize}
  \item if $\Gamma_G, \rho\Gamma_{\Psi} \vdash e : t$,
    then there exist $C', \rho'$ such that:
    \begin{itemize}
      \item $\rho' \vDash C'$;
      \item $\forall \upsilon \in \SV(\Gamma_{\Psi}, t), \rho \upsilon = \rho' \upsilon$; and
      \item $C, \Gamma_G, \Psi \vdash \erase{e} \rightsquigarrow C', e' \Rightarrow t'$ where $\Gamma_G, \Gamma_{\Psi} \vdash \rho' e' \conv e$ and $\Gamma_G, \Gamma_{\Psi} \vdash \rho' t \leq t$.
    \end{itemize}
\end{enumerate}
\end{conjecture}

\begin{theorem}[Soundness (wellformedness)]
If $\Gamma_G^\circ \rightsquigarrow \Gamma_G$ then $\WF{\Gamma_G, \mt}$.
\end{theorem}

\begin{proof}
By cases on the size inference rules for global declarations.
\begin{itemize}
  \item \refrule{a-global-nil}: Trivial.
  \item \refrule{a-global-assum}.
    \begin{displaymath}
      \inferrule*[]{
        \Gamma_G^\circ \rightsquigarrow \Gamma_G \\
        \set{}, \Gamma_G, \mt \vdash t^\circ \rightsquigarrow C_1, t \Rightarrow^* \varw \\
        \rho = \solve{C_1}
      }{
        \Gamma_G^\circ(\Assm{x}{t^\circ\!\!}) \rightsquigarrow \Gamma_G(\Assm{x}{\rho t})
      }
    \end{displaymath}
    By \autoref{thm:solve}, we have that $\rho \vDash C_1$.
    By the induction hypothesis, we have that $\WF{\Gamma_G, \mt}$.
    Then by \autoref{thm:soundness}, we have that $\Gamma_G, \mt \vdash \rho t : \varw$,
    and by \refrule{wf-global-assum}, we conclude that $\WF{\Gamma_G(\Assm{x}{\rho t}), \mt}$.
  \item \refrule{a-global-def}.
    \begin{displaymath}
      \inferrule*[]{
        \Gamma_G^\circ \rightsquigarrow \Gamma_G \\
        \set{}, \Gamma_G, \mt \vdash t^\circ \rightsquigarrow C_1, t \Rightarrow^* \varw \\\\
        C_1, \Gamma_G, \mt \vdash e^\circ \Leftarrow t \rightsquigarrow C_2, e \\
        \rho = \solve{C_2}
      }{
        \Gamma_G^\circ(\Defn{x}{t^\circ}{e^\circ\!\!}) \rightsquigarrow \Gamma_G(\Defn{x}{\rho t}{\rho e})
      }
    \end{displaymath}
    By \autoref{thm:solve}, we have that $\rho \vDash C_2$.
    By the induction hypothesis, we have that $\WF{\Gamma_G, \mt}$.
    Then by \autoref{thm:soundness}, we have that $\Gamma_G, \mt \vdash \rho t : \varw$ and $\Gamma_G, \mt \vdash \rho e : \rho t$.
    Finally, by \refrule{wf-global-def}, we conclude that $\WF{\Gamma_G(\Defn{x}{\rho t}{\rho e}), \mt}$.
\end{itemize}
\end{proof}

Note that well-formedness is \emph{not} complete;
that is, there exist well-formed global environments $\Gamma_G$ such that $\erase{\Gamma_G} \rightsquigarrow \Gamma_G$ does \emph{not} hold.
This is because \solve only returns \emph{one} single deterministic solution to a given constraint set, while \emph{any} solution will yield well-typed terms.

%%% Local Variables:
%%% TeX-master: "../main.tex"
%%% TeX-engine: default
%%% End:
