\section{Metatheory of \titlelang and Future Work}
\label{sec:metatheory}

In this section, we describe the metatheory of \lang.
Some of the metatheory is inherited or essentially similar to past work~\citep{cic-hat-minus,cc-hat-omega,cic-hat}, although we must adapt key proofs to account for differences in subtyping and definitions.
Complete proofs for a language like \lang are too involved to present in full, so we provide key lemmas and proof sketches; full proofs can be found in \anotherpdf.

In short, \lang satisfies confluence and subject reduction (with the same caveats as in CIC for cofixpoints).
Proofs of strong normalization and logical consistency for \lang, and soundness and completeness of the size inference algorithm with respect to the typing rules, remain future work.
We conjecture how the proofs of strong normalization and consistency should proceed based on past work~\citep{cic-hat-minus,cc-hat-omega,cic-hat}.

The metatheoretical investigations provide many interesting questions, so we discuss future work in context as these questions arise.

\subsection{Confluence}

We define $\rhd$ as the least compatible closure of \reduction and $\rhd^*$ as the reflexive--transitive closure of $\rhd$. Precise definitions are also provided in \autoref{sec:red-conv-trans}.

\begin{theorem}[Confluence]
\label{thm:metatheory:confluence}
  %
  Let $e, e_{1,2}$ be terms.
  %
  If $e_1 \prescript{*}{}{\lhd ~ } e \rhd^* e_2$ then
  $e_1 \rhd^* e' \prescript{*}{}{\lhd ~ } e_2$
  for a term $e'$.
  %
\end{theorem}
%
\begin{proof}[{[sketch]}]
  %
  We use the Takahashi translation technique due to \citet{takahashitrans}, which is a simplification of the standard
  parallel reduction technique.
  %
  The proof is straightforward.
  %
\end{proof}

\subsection{Subject Reduction}
\label{sec:meta:sub-red}

Suject reduction does not hold in \lang or in Coq due to the way coinductives are presented.
This is a well-known problem, discussed previously in a sized-types setting by \citet{cc-hat-omega},
on which our presentation of coinductives is based,
as well as by the Coq developers\footnote{The discussion of the problem and suggested solutions can be found here: \url{https://github.com/coq/coq/issues/5288/}.}.

In brief, the current presentation of coinductives requires that cofixpoint reduction be \textit{restricted},
\ie occurring only when it is the target of a case expression.
This allows for strong normalization of cofixpoints in much the same way restricting fixpoint reduction to when the recursive argument is syntactically a fully-applied constructor does.
One way this can break subject reduction is by making the type of a case expression not be convertible before and after the cofixpoint reduction.
As a concrete example, consider the following coinductive definition for conaturals.
\begin{displaymath}
  \defn{\Conat}{\Type{}}{\assm{\Succ}{\Conat \to \Conat}}
\end{displaymath}
For some motive $P$ and branch $e$, we have the following $\nu$-reduction.
\begin{align*}
  &\caseof{\erase{P}}{\cofix{1}{\omega}{\Conat}{\app{\Succ}{\omega}}}{\Succ}{e} \rhd_\nu \\
  &\caseof{\erase{P}}{\app{\Succ}{(\cofix{1}{\omega}{\Conat}{\app{\Succ}{\omega}})}}{\Succ}{e}
\end{align*}
Assuming both terms are well-typed, the former has type $\app{P}{(\cofix{1}{\omega}{\Conat}{\app{\Succ}{\omega}})}$ while the latter has type $\app{P}{(\app{\Succ}{(\cofix{1}{\omega}{\Conat}{\app{\Succ}{\omega}})})}$, but for an arbitrary $P$ these are not convertible without allowing cofixpoints to reduce arbitrarily.

On the other hand, if we do allow unrestricted reduction, subject reduction does hold.

\begin{theorem}[Subject Reduction]
  \label{thm:metatheory:sr}
  Let $\Sigma$ be a well-formed signature.
  Suppose that $\nu$-reduction to allows unrestricted reduction of cofixpoints.
  Then $\sgg \vdash e : t$ and $e \rhd e'$ implies $\sgg \vdash e' : t$.
\end{theorem}

\begin{proof}[{[sketch]}]
  By induction on $\sgg \vdash e : t$.
  Most cases are straightforward.
  The case for \refrule{case} where $e \rhd e'$ by $\iota$-reduction relies on the fact that
  if $x$ is the name of a \coinductive type and appears strictly positively in $t$,
  then $x$ appears covariantly in $t$.
  (This is only true without nested \coinductive types, which \lang disallows in well-formed signatures.)

  The case for \refrule{case} and $e$ (guarded) $\nu$-reduces to $e'$ requires an unrestricted $\nu$-reduction.
  After guarded $\nu$-reduction, the target (a cofixpoint) appears in the motive unguarded by a case expression, but must be unfolded to re-establish typing the type $t$.
\end{proof}

\subsubsection{The Problem with Nested Inductives}

\newcommand{\nat}{\const{N}}

Recall from \autoref{sec:typing} that we disallow nested \coinductive types.
This means that when defining a \coinductive type, it cannot recursively appear as the parameter of another type.
For instance, the following definition $\nat$, while equivalent to $\Nat$,
is disallowed due to the appearance of $\nat$ as a parameter of $\Box$.
\begin{align*}
  \defn{\nat}{\Type{}}{\seq{\assm{\Zero}{\nat}, \assm{\Succ}{\app{\Box}{\nat} \to \nat}}}
\end{align*}
Notice that we have the subtyping relation $\nat^\upsilon \leq \nat^{\hat{\upsilon}}$,
but by convertibility of parameters,
we do \emph{not} have $\app{\Box^\infty}{\nat^\upsilon} \leq \app{\Box^\infty}{\nat^{\hat{\upsilon}}}$.
This convertibility due to the removal of polarity annotations on \coinductive definitions is what allows us to retain backward compatibility.
But because case expressions on some target $\nat^{\hat{s}}$ force recursive arguments to have size $s$ exactly,
and the target also has type $\nat^{\hat{\hat{s}}}$ by cumulativity,
the argument of $\Succ$ could have both type $\app{\Box^\infty}{\nat^s}$ and $\app{\Box^\infty}{\nat^{\hat{s}}}$, violating convertibility.
We can exploit this fact and break subject reduction explicitly with the following counterexample term.
\begin{displaymath}
\begin{array}{l}
  \caseof*{\erase{\abs{\any}{\nat}{\nat^\infty}}}{\app{\Succ}{(\app{\MkBox}{\nat^{\hat{\upsilon}}}{\Zero})}}{\\
  \seq{\Zero \Rightarrow \Zero,\\
  \phantom{\langle} \Succ \Rightarrow \app{(\abs{A}{\Type{}}{\abs{x}{A}{\Zero}})}{(\app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}})}}}
\end{array}
\end{displaymath}
By cumulativity, the target can be typed as $\nat^{\hat{\upsilon}^{3}}$ (that is, with size $\hat{\hat{\hat{\upsilon}}}$).
By \refrule{case}, the second branch must then have type $\prod{x}{\app{\Box}{\nat^{\hat{\hat{\upsilon}}}}}{\nat^\infty}$ --- and so it does.
Then the case expression is well typed with type $\nat^\infty$.
However, once we reduce the the case expression, we end up with a term that is no longer well typed.
\begin{displaymath}
  \app{(\abs{A}{\Type{}}{\abs{x}{A}{\Zero}})}
    {(\app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}})}
    {(\app{\MkBox}{\nat^{\hat{\upsilon}}}{\Zero})}
\end{displaymath}
By \refrule{app}, the second argument should have type $\app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}}$ (or a subtype thereof), but it cannot:
the only type the second argument can have is $\app{\Box^\infty}{\nat^{\hat{\upsilon}}}$.

There are several possible solutions, all threats to backward compatibility.
\CIChat's solution is to require that constructors be fully-applied and that their parameters be bare terms,
so that we are forced to write $\app{\MkBox}{\nat}{\Zero}$.
The problem with this is that Coq treats constructors essentially like functions,
and assuring that they are fully applied with bare parameters would require either reworking how they are represented internally
or adding an intermediate step to elaborate partially-applied constructors into functions whose bodies are fully-applied constructors.
The other solution, as mentioned, is to add polarities back in, so that $\Box$ with positive polarity in its parameter yields the subtyping relation $\app{\Box^\infty}{\nat^{\hat{\upsilon}}} \leq \app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}}$.

Interestingly, because the implementation infers all size annotations from a completely bare program,
our counterexample and similar ones exploiting explicit size annotations aren't directly expressible,
and don't appear to be generated by the algorithm, which would solve for the smallest size annotations.
For the counterexample, in the second branch, the size annotation would be (a size constrained to be equal to) $\hat{\upsilon}$.
We conjecture that the terms synthesized by the inference algorithm do indeed satisfy subject reduction even in the presence of nested \coinductives,
although perhaps at the expense of other desired metatheoretical properties,
such as completeness of the algorithm with respect to the typing rules,
which we discuss in the next subsection.

\subsection{Soundness and Completeness of Size Inference}\label{sec:meta:sound-complete}
The size inference algorithm assigns fresh size variables to each \coinductive type and produces a set of size constraints; however, the typing rules of \lang state a relationship between a particular sized term and its sized type.
To prove soundness and completeness, we need the notions of a size substitution and satisfaction of a constraint system, introduced in \autoref{subsec:algorithm:wf}.
We further define composition, $(\rho_1 \circ \rho_2)(\upsilon) \coloneqq \rho_1(\rho_2(\upsilon))$, and pointwise mapping, $\rho(V) \coloneqq \set{s : \forall \upsilon \in V, \rho(\upsilon) = s}$.
Abusing notation, we write $\rho(V) = s$ to mean $\forall s' \in \rho(V), s' = s$.

Soundness and completeness of the size inference algorithm rely on notions of soundness and completeness for \RecCheck, stated below.
They have been slightly modified from their original defintions; we refer the reader to \anotherpdf and to \citet{f-hat} for the full proofs of SRC and CRC.

\begin{theorem}[Soundness of \RecCheck (SRC)]
  If $\RecCheck(C', \tau, V^*, V^\neq) = C$, for every $\rho$ such that $\rho \vDash C$, given a fresh stage variable $\upsilon$, there exists a $\rho'$ such that the following all hold:
  \begin{itemize}
    \item $\rho' \vDash C'$
    \item For all $\upsilon' \in V^\neq$, $(\subst{}{\upsilon}{\rho(\tau)} \circ \rho')(\upsilon') = \rho(\upsilon')$
    \item For all $\tau' \in V^*$, $(\subst{}{\upsilon}{\rho(\tau)} \circ \rho')(\tau') = \rho(\tau')$
    \item $\rho'(V^*) = \upsilon$
    \item $\floor{\rho'(V^\neq)} \neq \upsilon$
  \end{itemize}
  Intuitively, if \RecCheck succeeds with $C$, then given any substitution $\rho$ that satisfies $C$, there is another substitution $\rho'$ that satisfies the original constraint system $C'$ while also not violating any of the properties that \RecCheck enforces to produce $C$.
\end{theorem}

\begin{theorem}[Completeness of \RecCheck (CRC)]
  Suppose the following all hold:
  \begin{itemize}
    \item $\rho \vDash C'$
    \item $\rho(V^*) = \upsilon$
    \item $\floor{\rho(V^\neq)} \neq \upsilon$
  \end{itemize}
  Then $\RecCheck(C', \tau, V^*, V^\neq) = C$ and $\rho \vDash C$.
\end{theorem}

Given a generic environment $\Psi$, we use $\Gamma_\Psi$ to denote the environment stripped of all of the constraints in $\Psi$.
We can now state soundness and completeness of the checking, inference, and well-formedness portions of the algorithm.

\begin{theorem}[Soundness (check/infer)]
  Let $\Sigma$ be a fixed, well-formed signature.
  Suppose $\WF{\Sigma, \Gamma_G, \mt}$ holds.
  \begin{enumerate}
    \item If for every $\rho$ such that $\rho \vDash C$ the following hold:
      \begin{itemize}
        \item $\WF{\Sigma, \Gamma_G, \rho\Gamma_\Psi}$
        \item If $\Psi = \Psi_1 (C_1, x : u \coloneqq a) \Psi_2$, then $\forall \rho \vDash C_1$, we have $\Sigma, \Gamma_G, \rho \Gamma_{\Psi_1} \vdash \rho a : \rho u$
        \item $C, \Gamma_G, \Psi \vdash e^\circ \Leftarrow t \rightsquigarrow C', e$
      \end{itemize}
      Then for every $\rho$ such that $\rho \vDash C'$, $\Sigma, \Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$ holds.
    \item If for every $\rho$ such that $\rho \vDash C$ the following hold:
      \begin{itemize}
        \item $\WF{\Sigma, \Gamma_G, \rho\Gamma_\Psi}$
        \item If $\Psi = \Psi_1 (C_1, x : u \coloneqq a) \Psi_2$, then $\forall \rho \vDash C_1$, we have $\Sigma, \Gamma_G, \rho \Gamma_{\Psi_1} \vdash \rho a : \rho u$
        \item $C, \Gamma_G, \Psi \vdash e^\circ \rightsquigarrow C', e \Rightarrow t$
      \end{itemize}
      Then for every $\rho$ such that $\rho \vDash C'$, $\Sigma, \Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$ holds.
  \end{enumerate}
\end{theorem}

The third condition tells us our primary goal: if the checking or inference algorithm succeeds, then given a solution of the constraints it produces, the term is well-typed.
However, well-typedness under a malformed environment is meaningless, so we must also require that the environments we provide to the algorithm are well-formed, and that the constraints of generic environments are valid.

\begin{proof}[{[sketch]}]
  By simultaneous induction on the checking and inference judgements of the algorithm.
  We refer the reader to \anotherpdf for the bulk of the proof and to \citet{f-hat, cc-hat-omega} for further details.
  SRC is used in the cases of \refrule{a-fix} and \refrule{a-cofix}: if \RecCheckLoop succeeds, then there is some position annotation of the bare \cofixpoint type such that \RecCheck succeeds, and we can apply SRC.
  Since the typing rules use positivity and negativity while the algorithm uses subtyping, we also make use of a lemma stating if $\rho_1(V) \sqsubseteq \rho_2(V)$, then $V \pos t \implies \rho_1 t \leq \rho_2 t$ and $V \neg t \implies \rho_2 t \leq \rho_1 t$.
\end{proof}

\begin{theorem}[Soundness (well-formedness)]
  Let $\Sigma$ be a fixed, well-formed signature. \\
  If $\Gamma^\circ_G \rightsquigarrow \Gamma_G$, then $\WF{\Sigma, \Gamma_G, \mt}$ holds.
\end{theorem}

\begin{proof}[{[sketch]}]
  By induction on the well-formedness judgements of the algorithm.
  Again, we refer the reader to \anotherpdf for the bulk of the proof, which relies on the soundness of the checking and inference judgements.
  It also requires a lemma stating $\solve{C} \vDash C$ to ensure that global definitions are well-typed.
\end{proof}

\begin{conjecture}[Completeness]
  Let $\Sigma$ a fixed, well-formed signature.
  \begin{enumerate}
    \item\label{thm:completeness:checking} If $\Sigma, \Gamma_G, \rho\Gamma \vdash e : \rho t$ and $\rho \vDash C$, then there exist $C', \rho', \Psi, e'$ such that $\forall \upsilon \in \SV{\Gamma, t}, \rho(\upsilon) = \rho'(\upsilon)$ and $\rho' \vDash C'$ and $\Gamma_\Psi = \Gamma$ and $\rho' e' = e$ and $C, \Gamma_G, \Psi \vdash \erase{e} \Leftarrow t \rightsquigarrow C', e'$.
    \item\label{thm:completeness:inference} If $\Sigma, \Gamma_G, \rho\Gamma \vdash e : t$ and $\rho \vDash C$, then there exist $C', \rho', \Psi, e', t'$ such that $\forall \upsilon \in \SV{\Gamma}, \rho(\upsilon) = \rho'(\upsilon)$ and $\rho' \vDash C'$ and $\Gamma_\Psi = \Gamma$ and $\rho' e' = e$ and $\rho' t' \leq t$ and $C, \Gamma_G, \Psi \vdash \erase{e} \rightsquigarrow C', e' \Rightarrow t'$.
    \item\label{thm:completeness:wf} If $\WF{\Sigma, \Gamma_G, \mt}$, then $\erase{\Gamma_G} \rightsquigarrow \Gamma_G$.
  \end{enumerate}
\end{conjecture}

\begin{proof}[{[sketch]}]
  By induction on the typing judgement.
  We refer the reader to \citet{f-hat, cc-hat-omega} for the bulk of the proof details.
  We conjecture that if a \cofixpoint with position-annotated types $\overline{t_k}$ is well-typed, then \RecCheckLoop can find position annotations for $\overline{\erase{t_k}}$ that have at least the same position annotations as $\overline{t_k}$ such that \RecCheck succeeds, so that we can apply CRC.
\end{proof}

Completeness also remains a conjecture.
The core of the proof relies on a property of \RecCheckLoop that we have yet been able to figure out how to prove.
Further investigation into the completeness proof of \RecCheck from \Fhat may yield a proof technique.

\subsection{Strong Normalization and Logical Consistency}

Our ultimate goal and primary future work is to prove strong normalization and logical consistency of \lang.

\begin{conjecture}[Strong Normalization]\label{thm:metatheory:sn}
  %
  If $\sgg \vdash e : t$ then $e$ contains no infinite
  reduction sequences.
  %
\end{conjecture}

\begin{conjecture}[Logical Consistency]\label{thm:metatheory:lc}
  %
  The type $\prod{p}{\Prop}{p}$ is uninhabited in \lang.
  %
\end{conjecture}


Taking inspiration from \citet{cic-hat-minus,cc-hat-omega,cic-hat},
we conjecture that these statements can be proven using the
$\Lambda$-set technique from \citet{lambda-set-altenkrich,lambda-set-pts}.
Our proof attempt is still ongoing.

However, with coinduction and cofixpoints, results from \citet{cc-hat-omega}
suggest that subject reduction and strong
normalization may not be true at the same time, because subject
reduction appears to require unrestricted unfolding of cofixpoints,
which breaks normalization.

Recall that Coq itself is not strongly normalizing, only weakly normalizing.\footnote{At least, the underlying calculus is not. The counterexample ``normalizes'' to a stack overflow on machine with finite memory.}

\begin{minted}{coq}
Definition cbv_omega := fix f (n : nat) := let x := f n in O.
\end{minted}

This is a side-effect of relaxing the guard condition to enable more sound programs to type check.
Ideally, sufficiently expressive sized typing will allow us to replace the guard condition entirely and regain strong normalization in Coq.

However, an intermediate goal may be to achieve only weak normalization.
This would also maintain backward compatibility with Coq, although it is unclear if counterexamples like the above are ever desired in user programs.
