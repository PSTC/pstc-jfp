\section{Metatheory of \titlelang and Future Work}
\label{sec:metatheory}

In this section, we describe the metatheory of \lang.
Some of the metatheory is inherited or essentially similar to past work~\citep{cic-hat-minus,cc-hat-omega,cic-hat}, although we must adapt key proofs to account for differences in subtyping and definitions.
Complete proofs for a language like \lang are too involved to present in full, so we provide key lemmas and proof sketches; full proofs can be found in \anotherpdf.

In short, \lang satisfies confluence and subject reduction (with the same caveats as in CIC for cofixpoints).
Proofs of strong normalization and logical consistency for \lang, and soundness and completeness of the size inference algorithm with respect to the typing rules, remain future work.
We conjecture how the proofs of strong normalization and consistency should proceed based on past work~\citep{cic-hat-minus,cc-hat-omega,cic-hat}.

The metatheoretical investigations provide many interesting questions, so we discuss future work in context as these questions arise.

\subsection{Confluence}

We define $\rhd$ as the least compatible closure of \reduction and $\rhd^*$ as the reflexive--transitive closure of $\rhd$. Precise definitions are also provided in \autoref{sec:red-conv-trans}.

\begin{theorem}[Confluence]
\label{thm:metatheory:confluence}
  %
  Let $e, e_{1,2}$ be terms.
  %
  If $e_1 \prescript{*}{}{\lhd ~ } e \rhd^* e_2$ then
  $e_1 \rhd^* e' \prescript{*}{}{\lhd ~ } e_2$
  for a term $e'$.
  %
\end{theorem}
%
\begin{proof}[Proof Sketch]
  %
  We use the Takahashi translation technique due to \citet{takahashitrans}, which is a simplification of the standard
  parallel reduction technique.
  %
  The proof is straightforward.
  %
\end{proof}

\subsection{Subject Reduction}
\label{sec:meta:sub-red}
Subject reduction does not hold in CIC, or in Coq, due to cofixpoints\footnote{Discussion and counterexample can be found here: \url{https://github.com/coq/coq/issues/5288/}}.
In essence, the problem is that $\nu$\=/reduction can either be guarded to reduce under a case expression (dual to $\mu$-reduction which only reduces a fixpoint when applied to a constructor), enabling strong normalization but breaking subject reduction, or unrestricted, enabling subject reduction to hold but breaking strong normalization.

\lang, following Coq, implements the guarded $\nu$\=/reduction, so cofixpoints do not satisfy subject reduction.
Ongoing work in Coq seeks to change the semantics of cofixpoints to enable both subject reduction and strong normalization.

With unrestricted $\nu$\=/reduction, subject reduction and confluence hold for cofixpoints, but we conjecture strong normalization must fail.
\citet{cc-hat-omega} provides a nice discussion of this in a similar context.

\begin{theorem}[Subject Reduction]
  \label{thm:metatheory:sr}
  %
  Let $\Sigma$ be a well-formed signature.
  %
  Further, define $\nu$-reduction to allow unrestricted unfolding
  of cofixpoints.
  %
  Then, $\sgg \vdash e : t$ and $e \rhd e'$ implies
  $\sgg \vdash e' : t$.
  %
\end{theorem}
%
\begin{proof}[Proof Sketch]
  %
  By induction on $\sgg \vdash e : t$. Most cases are straightforward.

  The case for \refrule{case} where $e \rhd e'$ by $\iota$-reduction relies on the fact
  if $x$ is the name of a \coinductive types and appears strictly positively in
  $t$ then $x$ appears covariantly in $t$.
  (This is only true without nested \coinductive type, which recall, \lang disallows in well-formed signatures.)

  The case for \refrule{case} and $e$ (guarded) $\nu$-reduces to $e'$ requires an unrestricted $\nu$-reduction.
  After guarded $\nu$-reduction, the target (a cofixpoint) appears in the motive unguarded by a case expression, but must be unfolded to re-establish typing the type $t$.
\end{proof}

Recall from \autoref{sec:typing} that we disallow nested \coinductive types in our definition of strict positivity.
Unfortunately, as suggested in the above proof, subject reduction breaks in the presence of nested \coinductive types.
We present a counterexample shortly.
The root cause of this issue is the removal of polarity annotations from \CIChat to make \lang backward compatible with Coq.
In \CIChat, these polarity annotations must be provided by the user in the surface syntax and affect subtyping for \coinductive types.

Interestingly, counterexamples seem to be impossible to express in our implementation.
The counterexamples rely on crafting a set of bad annotations, but the user cannot provide annotations directly and is forced to rely on size inference.
The size inference algorithm seems unable to produce these bad annotations.
We conjecture that \lang programs whose size annotations are generated by the algorithm do enjoy subject reduction.
Future study of the inference algorithm should provide insight on how to add nested \coinductive types to \lang.

To see how subject reduction for \lang fails in the presence of nested \coinductive types, consider the following example. Again, we omit $\square$ in nonempty environments and brackets in singleton vectors, and we use a Coq-like syntax for case branches.
%
\begin{alignat*}{1}
  \Sigma
    & = ((A : \Type{}) (x : A) \vdash \textrm{Eq} : A \to \Type{} \coloneqq \textrm{eq\_refl} : \textrm{Eq} ~ A ~ x ~ x) \\
    & \phantom{==} (\square \vdash \textrm{N} : \Type{} \coloneqq
        \langle \textrm{O} : \textrm{N},
        \textrm{S} : (n: \textrm{N}) \to (n\textrm{=}n : \textrm{Eq} ~ \textrm{N} ~ n ~ n) \to \textrm{N} \rangle)
\end{alignat*}
%
Note that although N behaves extensionally like $\N$, it cannot
be encoded without the use of nested inductive types due to the
$(n\textrm{=}n : \text{Eq} ~ \text{N} ~ n ~ n)$ argument of S.
%
It is possible to see that
%
\begin{displaymath}
  \Sigma, \square, \square \vdash
  \left(
  \begin{array}{l}
    \text{case}_{\lambda \_: \text{N}. \text{N}} ~ (\text{S} ~ \text{O} ~ (\text{eq\_refl} ~ \text{N}^{\upsilon+1} ~ \text{O})) ~
    \text{of} \\
    \mid \text{O} \Rightarrow \text{O} \\
    \mid \text{S} \Rightarrow \abs{n}{\text{N}}{\abs{n\text{=}n}{\text{Eq} ~ \text{N} ~ n ~ n}{}} \\
    \qquad\quad \text{seq} ~ (\text{eq\_refl} ~ (\text{Eq}^\infty ~ \text{N}^{\upsilon+2} ~ n ~ n) ~ n\text{=}n) ~ \text{O}
  \end{array}
  \right)
  : \text{N}^\infty
  \label{case-ex}\tag{case-ex}
\end{displaymath}
%
where $\upsilon$ is a size variable,
$\textrm{seq} = \abs{\_}{\_}{\abs{n}{\text{N}}{n}}$,
and we use the shorthand $\upsilon+k$ to mean the $k$-th successor stage of $\upsilon$.
%
However, this case expression reduces to the ill-typed expression in $\Sigma, \square, \square$:
%
\begin{displaymath}
  \left(
  \begin{array}{l}
    \abs{n}{\text{N}}{\abs{n\text{=}n}{\text{Eq} ~ \text{N} ~ n ~ n}{}} \\
    \quad \text{seq} ~ (\text{eq\_refl} ~ (\text{Eq}^\infty ~ \text{N}^{\upsilon+2} ~ n ~ n) ~ n\text{=}n) ~ \text{O}
  \end{array}
  \right)
  ~ \text{O} ~ (\text{eq\_refl} ~ \text{N}^{\upsilon+1} ~ \text{O})
  \label{case-red-ex}\tag{case-red-ex}
\end{displaymath}
%


% \ML{Should I go into detail?}
%
In detail, first observe that the original case expression is
well-typed as follows.
%
By \refrule{constr} and \refrule{conv}, $\Sigma,\square,\square \vdash \textrm{S} ~
 ~ \textrm{O} ~ (\textrm{eq\_refl} ~ \textrm{N}^{\upsilon+1} ~ \textrm{O})
 : \textrm{N}^{\upsilon+2} \leq \textrm{N}^{\upsilon+3}$.
% By \refrule{constr},
% $\Sigma,\square,\square \vdash \textrm{O} : \textrm{N}^{\upsilon+1}$
% and so $\Sigma,\square,\square \vdash (\textrm{eq\_refl} ~
% \textrm{N}^{\upsilon+1} ~ \textrm{O}) : \textrm{Eq}^\infty
% ~ \textrm{N}^{\upsilon+1} ~ \textrm{O} ~ \textrm{O}$ by \refrule{constr}.
% %
% Hence, $\Sigma,\square,\square \vdash \textrm{S} ~
% ~ \textrm{O} ~ (\textrm{eq\_refl} ~ \textrm{N}^{\upsilon+1} ~ \textrm{O})
% : \textrm{N}^{\upsilon+2} \leq \textrm{N}^{\upsilon+3}$ by \refrule{constr} and
% \refrule{conv}.
%
Now, let $\wp = \lambda\_:\textrm{N}^{\upsilon+3}.\textrm{N}^{\infty}$,
and let $e_{\textrm{O}}, e_{\textrm{S}}$ respectively be the O and S branches in
the case expression above.
%
Put $s = \upsilon+2$ so that $\Sigma,\square,\square \vdash \textrm{S} ~
\textrm{O} ~ (\textrm{eq\_refl} ~ \textrm{N}^{\upsilon+1} ~ \textrm{O})
: \textrm{N}^{s+1}$.
%
We can show $\Sigma,\square,\square \vdash e_{\textrm{O}} = \textrm{O} : \textrm{N}^\infty
\approx \branchtype{\Sigma}{\cdot}{\textrm{O}}{s}{\wp}$.
%
\begin{displaymath}
  \Sigma, \square, (n: \text{N}^s) (n\text{=}n : \text{Eq}^\infty ~ \text{N}^s ~ n ~ n)
  \vdash
  (\text{eq\_refl} ~ (\text{Eq}^\infty ~ \text{N}^{\upsilon+2} ~ n ~ n) ~ n\text{=}n)
  : \text{Eq}^\infty ~ \text{N}^s ~ n ~ n
\end{displaymath}
%
by \refrule{case} and \refrule{lam} and because $s = \upsilon+2$ by choice.
%
Since seq returns its second argument, which is O in $e_{\textrm{S}}$,
it follows that
$\Sigma,\square,\square \vdash e_{\textrm{S}} : \textrm{N}^\infty
\approx \branchtype{\Sigma}{\cdot}{\textrm{S}}{s}{\wp}$.
%
This verifies \eqref{case-ex}.


To see that \eqref{case-red-ex} is not well-typed, note that
$\textrm{eq\_refl} \; (\textrm{Eq}^\infty ~
\textrm{N}^{\upsilon+2} ~ n ~ n) \; n\textrm{=}n$
can only be well-typed in a $\Gamma$ such that
$\Sigma,\square,\Gamma \vdash n\textrm{=}n : \textrm{Eq}^\infty ~ \textrm{N}^{\upsilon+2} ~ n ~ n$,
which means that $(n\textrm{=}n : \textrm{Eq}^\_ ~ \textrm{N}^{\upsilon+2} ~ n ~ n) \in \Gamma$
because \refrule{conv} and \refrule{st-app} state that arguments
must be convertible (here $\textrm{Eq}^\_$ means the annotation for
$\textrm{Eq}$ is irrelevant to our discussion).
%
In other words, all attempts to type $e_{\textrm{S}}$ in $\Sigma,\square,\square$
will result in
$\Sigma,\square,\square \vdash e_{\textrm{S}} : \prod{n}{\textrm{N}^\_}{\prod{n\textrm{=}n}{\textrm{Eq}^\_ ~ \textrm{N}^{\upsilon+2} ~ n ~ n}{\textrm{N}^\_}}$.
%
On the other hand, since \refrule{conv} and \refrule{st-app} state
that arguments must be convertible in order to have subtyping,
all attempts to type $(\textrm{eq\_refl N}^{\upsilon+1} ~ \textrm{O O})$
in $\Sigma,\square,\square$ will result in
$\Sigma,\square,\square \vdash
(\textrm{eq\_refl N}^{\upsilon+1} ~ \textrm{O O}) :
\textrm{Eq}^\_ ~ \textrm{N}^{\upsilon+1} ~ \_ ~ \_$.
%
Since $\textrm{N}^{\upsilon+1} \napprox \textrm{N}^{\upsilon+2}$, all attempts
to type \eqref{case-red-ex} will fail, thus breaking subject
reduction.

As observed, the key to this counterexample
breaking subject reduction is the $\textrm{eq\_refl} \;
(\textrm{Eq}^\infty \allowbreak ~ \textrm{N}^{\upsilon+2} ~ n ~ n) \; n\textrm{=}n$
subterm of $e_{\textrm{S}}$:
%
it exploits the fact that subtyping between inductive types
requires the parameters to be convertible, as specified in
\refrule{st-app}.
%
A straightforward attempt to fix this issue would be to modify
\refrule{st-app} so that $t_1 ~ t_2 \leq t_1' ~ t_2'$ provided that
$t_i \leq t_i'$ for $i = 1,2$.
%
% That is, $I^{s_I} ~ J^{s_J} \leq I^{s_I'} ~ J^{s_J'}$ just in case
% $s_I \sqsubseteq s_I'$ while $s_J = s_J'$ when $I, J$ are
% inductive types.
% %
% However, as size expressions intuitively refer to ``how
% large/deep an object can be'', intuitively we would like to allow
% the subtyping to hold when $s_J \sqsubseteq s_J'$.
% %
% For example, each list of type $\textrm{List}^{\infty} ~
% \textrm{Nat}^{s}$ is a list containing naturals not exceeding $s$, so it
% should also be a list containing naturals not exceeding any
% $s' \sqsupseteq s$ and hence inhabit the type
% $\textrm{List}^{\infty} ~ \textrm{Nat}^{s'}$.
% %
% This is not the case in \lang, because as mentioned in
% \autoref{subsec:typing:subtyping}, we require the
% parameters to be convertible in order to stay faithful to the
% implementation~\citep{impl}.
%
However, since \lang allows both universe subtyping and size subtyping,
and the universe subtyping rules in the Coq
manual~\citep{coq} require arguments and parameters to be convertible,
this straightforward solution may cause unforeseen
problems with universe subtyping.
% the solution to this subtyping problem will be more
% involved than just allowing parameters to be convertible.


Alternatively, we may take inspiration from \CIChatminus, which satisfies
subject reduction. This issue is not present in \CIChatminus because it
syntactically requires parameters supplied to
constructors to be bare, so the above example (specifically the term
$\textrm{eq\_refl} \; (\textrm{Eq}^\infty ~ \textrm{N}^{\upsilon+2} ~
n ~ n) \; n\textrm{=}n$) would not conform to \CIChatminus grammar.
%
However, this requires constructors to be treated separately from
normal functions in applications and thus more changes to the
Coq kernel with unforeseen consequences.


%\ML{I haven't fully read Abel's paper but I think this is one of the
%main contributions of that paper. Does what I have here make sense?}
%
Another possible solution is to consider the principle of ``size
irrelevance'' in subtyping and type equality checking.
%
This idea, investigated by \citet{sizeirrelevance}, essentially allows
the type system to ignore sizes where they act as \emph{type arguments}.
%
That is, size information will be irrelevant in
constructor applications and term-level function applications.
%
For instance, the size information $\infty, \upsilon+2$ in
$\textrm{eq\_refl} \; (\textrm{Eq}^\infty ~ \textrm{N}^{\upsilon+2} ~
n ~ n) \; n\textrm{=}n$ will be treated as irrelevant, thus allowing
us to type this term in an environment where $n\textrm{=}n$ has
type $\textrm{Eq}^\_ ~ \textrm{N}^{\upsilon+1} ~ \_ ~ \_$.
%
However, sizes still remain relevant in places
where they act as \emph{regular arguments}, such as $\upsilon$ in
$\textrm{N}^\upsilon$.
%
At this point, how such a solution would be expressed in \lang and
its metatheoretical implications remain unclear.

\subsection{Soundness and Completeness of Size Inference}\label{sec:meta:sound-complete}
The size inference algorithm assigns fresh size variables to each \coinductive type and produces a set of size constraints; however, the typing rules of \lang state a relationship between a particular sized term and its sized type.
To prove soundness and completeness, we need the notions of a size substitution and satisfaction of a constraint system, introduced in \autoref{subsec:algorithm:wf}.
We further define composition, $(\rho_1 \circ \rho_2)(\upsilon) \coloneqq \rho_1(\rho_2(\upsilon))$, and pointwise mapping, $\rho(V) \coloneqq \set{s : \forall \upsilon \in V, \rho(\upsilon) = s}$.
Abusing notation, we write $\rho(V) = s$ to mean $\forall s' \in \rho(V), s' = s$.

Soundness and completeness of the size inference algorithm rely on notions of soundness and completeness for \RecCheck, stated below.
They have been slightly modified from their original defintions; we refer the reader to \anotherpdf and to \citet{f-hat} for the full proofs of SRC and CRC.

\begin{theorem}[Soundness of \RecCheck (SRC)]
  If $\RecCheck(C', \tau, V^*, V^\neq) = C$, for every $\rho$ such that $\rho \vDash C$, given a fresh stage variable $\upsilon$, there exists a $\rho'$ such that the following all hold:
  \begin{itemize}
    \item $\rho' \vDash C'$
    \item For all $\upsilon' \in V^\neq$, $(\subst{}{\upsilon}{\rho(\tau)} \circ \rho')(\upsilon') = \rho(\upsilon')$
    \item For all $\tau' \in V^*$, $(\subst{}{\upsilon}{\rho(\tau)} \circ \rho')(\tau') = \rho(\tau')$
    \item $\rho'(V^*) = \upsilon$
    \item $\floor{\rho'(V^\neq)} \neq \upsilon$
  \end{itemize}
  Intuitively, if \RecCheck succeeds with $C$, then given any substitution $\rho$ that satisfies $C$, there is another substitution $\rho'$ that satisfies the original constraint system $C'$ while also not violating any of the properties that \RecCheck enforces to produce $C$.
\end{theorem}

\begin{theorem}[Completeness of \RecCheck (CRC)]
  Suppose the following all hold:
  \begin{itemize}
    \item $\rho \vDash C'$
    \item $\rho(V^*) = \upsilon$
    \item $\floor{\rho(V^\neq)} \neq \upsilon$
  \end{itemize}
  Then $\RecCheck(C', \tau, V^*, V^\neq) = C$ and $\rho \vDash C$.
\end{theorem}

Given a generic environment $\Psi$, we use $\Gamma_\Psi$ to denote the environment stripped of all of the constraints in $\Psi$.
We can now state soundness and completeness of the checking, inference, and well-formedness portions of the algorithm.

\begin{theorem}[Soundness (check/infer)]
  Let $\Sigma$ be a fixed, well-formed signature.
  Suppose $\WF{\Sigma, \Gamma_G, \square}$ holds.
  \begin{enumerate}
    \item If for every $\rho$ such that $\rho \vDash C$ the following hold:
      \begin{itemize}
        \item $\WF{\Sigma, \Gamma_G, \rho\Gamma_\Psi}$
        \item If $\Psi = \Psi_1 (C_1, x : u \coloneqq a) \Psi_2$, then $\forall \rho \vDash C_1$, we have $\Sigma, \Gamma_G, \rho \Gamma_{\Psi_1} \vdash \rho a : \rho u$
        \item $C, \Gamma_G, \Psi \vdash e^\circ \Leftarrow t \rightsquigarrow C', e$
      \end{itemize}
      Then for every $\rho$ such that $\rho \vDash C'$, $\Sigma, \Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$ holds.
    \item If for every $\rho$ such that $\rho \vDash C$ the following hold:
      \begin{itemize}
        \item $\WF{\Sigma, \Gamma_G, \rho\Gamma_\Psi}$
        \item If $\Psi = \Psi_1 (C_1, x : u \coloneqq a) \Psi_2$, then $\forall \rho \vDash C_1$, we have $\Sigma, \Gamma_G, \rho \Gamma_{\Psi_1} \vdash \rho a : \rho u$
        \item $C, \Gamma_G, \Psi \vdash e^\circ \rightsquigarrow C', e \Rightarrow t$
      \end{itemize}
      Then for every $\rho$ such that $\rho \vDash C'$, $\Sigma, \Gamma_G, \rho\Gamma_\Psi \vdash \rho e : \rho t$ holds.
  \end{enumerate}
\end{theorem}

The third condition tells us our primary goal: if the checking or inference algorithm succeeds, then given a solution of the constraints it produces, the term is well-typed.
However, well-typedness under a malformed environment is meaningless, so we must also require that the environments we provide to the algorithm are well-formed, and that the constraints of generic environments are valid.

\begin{proof}[Proof Sketch]
  By simultaneous induction on the checking and inference judgements of the algorithm.
  We refer the reader to \anotherpdf for the bulk of the proof and to \citet{f-hat, cc-hat-omega} for further details.
  SRC is used in the cases of \refrule{a-fix} and \refrule{a-cofix}: if \RecCheckLoop succeeds, then there is some position annotation of the bare \cofixpoint type such that \RecCheck succeeds, and we can apply SRC.
  Since the typing rules use positivity and negativity while the algorithm uses subtyping, we also make use of a lemma stating if $\rho_1(V) \sqsubseteq \rho_2(V)$, then $V \pos t \implies \rho_1 t \leq \rho_2 t$ and $V \neg t \implies \rho_2 t \leq \rho_1 t$.
\end{proof}

\begin{theorem}[Soundness (well-formedness)]
  Let $\Sigma$ be a fixed, well-formed signature. \\
  If $\Gamma^\circ_G \rightsquigarrow \Gamma_G$, then $\WF{\Sigma, \Gamma_G, \square}$ holds.
\end{theorem}

\begin{proof}[Proof Sketch]
  By induction on the well-formedness judgements of the algorithm.
  Again, we refer the reader to \anotherpdf for the bulk of the proof, which relies on the soundness of the checking and inference judgements.
  It also requires a lemma stating $\solve{C} \vDash C$ to ensure that global definitions are well-typed.
\end{proof}

\begin{conjecture}[Completeness]
  Let $\Sigma$ a fixed, well-formed signature.
  \begin{enumerate}
    \item\label{thm:completeness:checking} If $\Sigma, \Gamma_G, \rho\Gamma \vdash e : \rho t$ and $\rho \vDash C$, then there exist $C', \rho', \Psi, e'$ such that $\forall \upsilon \in \SV{\Gamma, t}, \rho(\upsilon) = \rho'(\upsilon)$ and $\rho' \vDash C'$ and $\Gamma_\Psi = \Gamma$ and $\rho' e' = e$ and $C, \Gamma_G, \Psi \vdash |e| \Leftarrow t \rightsquigarrow C', e'$.
    \item\label{thm:completeness:inference} If $\Sigma, \Gamma_G, \rho\Gamma \vdash e : t$ and $\rho \vDash C$, then there exist $C', \rho', \Psi, e', t'$ such that $\forall \upsilon \in \SV{\Gamma}, \rho(\upsilon) = \rho'(\upsilon)$ and $\rho' \vDash C'$ and $\Gamma_\Psi = \Gamma$ and $\rho' e' = e$ and $\rho' t' \leq t$ and $C, \Gamma_G, \Psi \vdash |e| \rightsquigarrow C', e' \Rightarrow t'$.
    \item\label{thm:completeness:wf} If $\WF{\Sigma, \Gamma_G, \square}$, then $|\Gamma_G| \rightsquigarrow \Gamma_G$.
  \end{enumerate}
\end{conjecture}

\begin{proof}[Proof Sketch]
  By induction on the typing judgement.
  We refer the reader to \citet{f-hat, cc-hat-omega} for the bulk of the proof details.
  We conjecture that if a \cofixpoint with position-annotated types $\overline{t_k}$ is well-typed, then \RecCheckLoop can find position annotations for $\overline{|t_k|}$ that have at least the same position annotations as $\overline{t_k}$ such that \RecCheck succeeds, so that we can apply CRC.
\end{proof}

Completeness also remains a conjecture.
The core of the proof relies on a property of \RecCheckLoop that we have yet been able to figure out how to prove.
Further investigation into the completeness proof of \RecCheck from \Fhat may yield a proof technique.

\subsection{Strong Normalization and Logical Consistency}

Our ultimate goal and primary future work is to prove strong normalization and logical consistency of \lang.

\begin{conjecture}[Strong Normalization]\label{thm:metatheory:sn}
  %
  If $\sgg \vdash e : t$ then $e$ contains no infinite
  reduction sequences.
  %
\end{conjecture}

\begin{conjecture}[Logical Consistency]\label{thm:metatheory:lc}
  %
  The type $\prod{p}{\Prop}{p}$ is uninhabited in \lang.
  %
\end{conjecture}


Taking inspiration from \citet{cic-hat-minus,cc-hat-omega,cic-hat},
we conjecture that these statements can be proven using the
$\Lambda$-set technique from \citet{lambda-set-altenkrich,lambda-set-pts}.
Our proof attempt is still ongoing.

However, with coinduction and cofixpoints, results from \citet{cc-hat-omega}
suggest that subject reduction and strong
normalization may not be true at the same time, because subject
reduction appears to require unrestricted unfolding of cofixpoints,
which breaks normalization.

Recall that Coq itself is not strongly normalizing, only weakly normalizing.\footnote{At least, the underlying calculus is not. The counterexample ``normalizes'' to a stack overflow on machine with finite memory.}

\begin{minted}{coq}
Definition cbv_omega := fix f (n : nat) := let x := f n in O.
\end{minted}

This is a side-effect of relaxing the guard condition to enable more sound programs to type check.
Ideally, sufficiently expressive sized typing will allow us to replace the guard condition entirely and regain strong normalization in Coq.

However, an intermediate goal may be to achieve only weak normalization.
This would also maintain backward compatibility with Coq, although it is unclear if counterexamples like the above are ever desired in user programs.
