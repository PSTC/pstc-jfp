\section{Metatheoretical Results}
\label{sec:metatheory}

In this section, we describe the metatheory of \lang.
Some of the metatheory is inherited or essentially similar to past work~\citep{cic-hat-minus,cc-hat-omega,cic-hat},
although we must adapt key proofs to account for differences in subtyping and definitions.
Complete proofs for a language like \lang are too involved to present in full,
so we provide only key lemmas and proof sketches.

In short, \lang satisfies confluence and subject reduction, with the same caveats as in CIC for cofixpoints.
Proofs of strong normalization and logical consistency for \lang remain future work.
% TODO: Why a conjecture and not a proof? Because it hard.
We conjecture how the proofs of strong normalization and consistency should proceed based on past work~\citep{cic-hat-minus,cc-hat-omega,cic-hat}.

\subsection{Confluence}

Recall that we define $\rhd$ as the congruent closure of \reduction and $\rhd^*$ as the reflexive--transitive closure of $\rhd$.

\begin{theorem}[Confluence]
\label{thm:metatheory:confluence}
  If $\gg \vdash e \rhd^* e_1$ and $\gg \vdash e \rhd^* e_2$,
  then there is some term $e'$ such that $\gg \vdash e_1 \rhd^* e'$ and $\gg \vdash e_2 \rhd^* e'$.
\end{theorem}

\begin{proof}[{[sketch]}]
  We use the Takahashi translation technique due to \citet{takahashitrans},
  which is a simplification of the standard parallel reduction technique.
  It uses the Takahashi translation $e^\dagger$ of terms $e$,
  defined as the simultaneous single-step reduction of all
  $\beta\zeta\delta\Delta\iota\mu\nu$-redexes of $e$ in left-most inner-most order.
  The proof is relatively standard thanks to reduction being purely syntactic and untyped.
  % Is it though?
\end{proof}

\subsection{Subject Reduction}
\label{sec:metatheory:sub-red}

Suject reduction does not hold in \lang or in Coq due to the way coinductives are presented.
This is a well-known problem, discussed previously in a sized-types setting by \citet{cc-hat-omega},
on which our presentation of coinductives is based,
as well as by the Coq developers\footnote{The discussion of the problem and suggested solutions can be found here: \url{https://github.com/coq/coq/issues/5288/}.}.

In brief, the current presentation of coinductives requires that cofixpoint reduction be \textit{restricted},
\ie occurring only when it is the target of a case expression.
This allows for strong normalization of cofixpoints in much the same way restricting fixpoint reduction to when the recursive argument is syntactically a fully-applied constructor does.
One way this can break subject reduction is by making the type of a case expression not be convertible before and after the cofixpoint reduction.
As a concrete example, consider the following coinductive definition for conaturals.
\begin{displaymath}
  \seq{\assm{\Conat}{\Type{}}} \coloneqq {\seq{\assm{\Succ}{\Conat \to \Conat}}}
\end{displaymath}
For some motive $P$ and branch $e$, we have the following $\nu$-reduction.
\begin{align*}
  &\caseof*{\erase{P}}{\cofix*{1}{\defn{\omega}{\Conat}{\app{\Succ}{\omega}}}}{\seq{\Succ \Rightarrow e}} \rhd_\nu \\
  &\caseof*{\erase{P}}{\app{\Succ}{(\cofix*{1}{\defn{\omega}{\Conat}{\app{\Succ}{\omega}}})}}{\seq{\Succ \Rightarrow e}}
\end{align*}
Assuming both terms are well-typed, the former has type $\app{P}{(\cofix*{1}{\defn{\omega}{\Conat}{\app{\Succ}{\omega}}})}$ while the latter has type $\app{P}{(\app{\Succ}{(\cofix*{1}{\defn{\omega}{\Conat}{\app{\Succ}{\omega}})}})}$, but for an arbitrary $P$ these are not convertible without allowing cofixpoints to reduce arbitrarily.

\begin{figure}
  \fbox{$\gg \vdash e \reduce_{\beta\zeta\delta\Delta\iota\mu\nu'} e$} \hfill
  \vspace{-3ex}
  \begin{align*}
    \dots & \\
    \gg \vdash q_m & \reduce_{\nu'} \substvec{e_m}{f_k}{q_k} \\
    \textit{where} ~ & \forall i \in \vec{k}, q_i \equiv \cofix{i}{f_k}{t_k}{e_k}
  \end{align*}
  \caption{Reduction rules with unrestricted cofixpoint reduction}
  \label{fig:reduction-alt}
\end{figure}

On the other hand, if we do allow unrestricted $\nu$-reduction as in \autoref{fig:reduction-alt}, subject reduction does hold,
at the expense of normalization,
as a cofixpoint on its own could reduce indefinitely.

\begin{theorem}[Subject Reduction]
  \label{thm:metatheory:sr}
  Let $\Sigma$ be a well-formed signature.
  Suppose that $\nu$-reduction to allows unrestricted reduction of cofixpoints.
  Then $\gg \vdash e : t$ and $e \rhd e'$ implies $\gg \vdash e' : t$.
\end{theorem}

\begin{proof}[{[sketch]}]
  By induction on $\gg \vdash e : t$.  Most cases are straightforward,
  making use of confluence when necessary, such as for a lemma of
  $\Pi$-injectivity to handle $\beta$-reduction in \refrule{app}.
  %
  The case for \refrule{case} where $e \rhd e'$ by $\iota$-reduction relies on the fact that
  if $x$ is the name of a \coinductive type and appears strictly positively in $t$,
  then $x$ appears covariantly in $t$.
  (This is only true without nested \coinductive types, which \lang disallows in well-formed signatures.)

  The case for \refrule{case} and $e$ (guarded) $\nu$-reduces to $e'$ requires an unrestricted $\nu$-reduction.
  After guarded $\nu$-reduction, the target (a cofixpoint) appears in the motive unguarded by a case expression, but must be unfolded to re-establish typing the type $t$.
\end{proof}

\subsubsection{The Problem with Nested Inductives}

\newcommand{\nat}{\const{N}}

Recall from \autoref{sec:typing} that we disallow nested \coinductive types.
This means that when defining a \coinductive type, it cannot recursively appear as the parameter of another type.
For instance, the following definition $\nat$, while equivalent to $\Nat$,
is disallowed due to the appearance of $\nat$ as a parameter of $\Box$.
\begin{align*}
  \seq{\assm{\nat}{\Type{}}} \coloneqq \seq{\assm{\Zero}{\nat}, \assm{\Succ}{\app{\Box}{\nat} \to \nat}}
\end{align*}
Notice that we have the subtyping relation $\nat^\upsilon \leq \nat^{\hat{\upsilon}}$,
but as all parameters are invariant for backward compatibility and need to be convertible,
we do \emph{not} have $\app{\Box^\infty}{\nat^\upsilon} \leq \app{\Box^\infty}{\nat^{\hat{\upsilon}}}$.
But because case expressions on some target $\nat^{\hat{s}}$ force recursive arguments to have size $s$ exactly,
and the target also has type $\nat^{\hat{\hat{s}}}$ by cumulativity,
the argument of $\Succ$ could have both type $\app{\Box^\infty}{\nat^s}$ and $\app{\Box^\infty}{\nat^{\hat{s}}}$, violating convertibility.
We exploit this fact and break subject reduction explicitly with the following counterexample term.
\begin{displaymath}
\begin{array}{l}
  \caseof*{\erase{\abs{\any}{\nat}{\nat^\infty}}}{\app{\Succ}{(\app{\MkBox}{\nat^{\hat{\upsilon}}}{\Zero})}}{\\
  \seq{\Zero \Rightarrow \Zero,\\
  \phantom{\langle} \Succ \Rightarrow \app{(\abs{A}{\Type{}}{\abs{x}{A}{\Zero}})}{(\app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}})}}}
\end{array}
\end{displaymath}
By cumulativity, the target can be typed as $\nat^{\hat{\upsilon}^{3}}$ (that is, with size $\hat{\hat{\hat{\upsilon}}}$).
By \refrule{case}, the second branch must then have type $\prod{x}{\app{\Box}{\nat^{\hat{\hat{\upsilon}}}}}{\nat^\infty}$ --- and so it does.
Then the case expression is well typed with type $\nat^\infty$.
However, once we reduce the the case expression, we end up with a term that is no longer well typed.
\begin{displaymath}
  \app{(\abs{A}{\Type{}}{\abs{x}{A}{\Zero}})}
    {(\app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}})}
    {(\app{\MkBox}{\nat^{\hat{\upsilon}}}{\Zero})}
\end{displaymath}
By \refrule{app}, the second argument should have type $\app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}}$ (or a subtype thereof), but it cannot:
the only type the second argument can have is $\app{\Box^\infty}{\nat^{\hat{\upsilon}}}$.

There are several possible solutions, all threats to backward compatibility.
\CIChat's solution is to require that constructors be fully-applied and that their parameters be bare terms,
so that we are forced to write $\app{\MkBox}{\nat}{\Zero}$.
The problem with this is that Coq treats constructors essentially like functions,
and assuring that they are fully applied with bare parameters would require either reworking how they are represented internally
or adding an intermediate step to elaborate partially-applied constructors into functions whose bodies are fully-applied constructors.
The other solution, as mentioned, is to add polarities back in, so that $\Box$ with positive polarity in its parameter yields the subtyping relation $\app{\Box^\infty}{\nat^{\hat{\upsilon}}} \leq \app{\Box^\infty}{\nat^{\hat{\hat{\upsilon}}}}$.

Interestingly, because the implementation infers all size annotations from a completely bare program,
our counterexample and similar ones exploiting explicit size annotations aren't directly expressible,
and don't appear to be generated by the algorithm, which would solve for the smallest size annotations.
For the counterexample, in the second branch, the size annotation would be (a size constrained to be equal to) $\hat{\upsilon}$.
We conjecture that the terms synthesized by the inference algorithm do indeed satisfy subject reduction even in the presence of nested \coinductives,
although perhaps at the expense of other desired metatheoretical properties,
such as completeness of the algorithm with respect to the typing rules,
which we discuss in the next subsection.

\subsection{Strong Normalization and Logical Consistency}\label{sec:metatheory:sn}

Our ultimate goal and primary future work is to prove strong normalization and logical consistency of \lang.

\begin{conjecture}[Strong Normalization]\label{thm:metatheory:sn}
  %
  If $\gg \vdash e : t$ then $e$ contains no infinite
  reduction sequences.
  %
\end{conjecture}

\begin{conjecture}[Logical Consistency]\label{thm:metatheory:lc}
  %
  The type $\prod{p}{\Prop}{p}$ is uninhabited in \lang.
  %
\end{conjecture}


Taking inspiration from \citet{cic-hat-minus,cc-hat-omega,cic-hat},
we conjecture that these statements are likely true.
% Our proof attempt is still ongoing.

In fact, we have proof that a formulation of CIC with sized types,
alternative to \lang, is strongly normalizing.
%
This proof is uses a semantics-first set-theoretic model construction
equipped with realisability candidates based on the works of
\citet{barras-thesis}.
%
This alternative formulation differs from \lang in the following
aspects:
%
\begin{itemize}
  %
  \item One requires size variables to be explicitly annotated, and
  treat fixpoint recursor as binders for size variables.
  %
  That is, fixpoint recursors are now of the form such as
  %
  \begin{align*}
    \left\{\kw{fix}^\upsilon ~ f : \prod{n}{\Nat^\upsilon}{u} \coloneqq e\right\}_s
    \tag{$\star$}\label{eqn:new-fix}
  \end{align*}
  %
  where $f$ is said to \emph{bind} the size variable $\upsilon$ in $e$
  and the subscript size expression $s$ states that one may only call
  the fixpoint recursor on inputs of size $s$ or less.
  %
  This explicit binding of size variables serves the purpose of
  specifying which argument the recursion is happening on.
  %
  The fact that the fixpoint recursor is specialized to size $s$ is
  reflected by the corresponding typing rule:
  %
  \begin{mathparpagebreakable}
    \inferrule*[right=\defrule{fix-another}]
    { \Gamma (f : \prod{n}{\Nat^\upsilon}{u}) \vdash e :
      \prod{n}{\Nat^{\hat{\upsilon}}}{\subst{u}{\upsilon}{\hat{\upsilon}}} }
    { \Gamma \vdash \left\{\kw{fix}^\upsilon ~ f : \prod{n}{\Nat^\upsilon}{u}\right\}_s \coloneqq e :
      \prod{n}{\Nat^{s}}{\subst{u}{\upsilon}{s}} }
  \end{mathparpagebreakable}
  %
  \item One only considers predicative W-types in order to alleviate
  some syntactic burden of dealing with strict positivity conditions.
  %
  However, \citet{barras-thesis,polynomial-functors-w} have shown that
  W-types are powerful enough to encode many strictly positive
  inductive definitions, including nested inductive types and
  inductive types with non-uniform parameters.
  %
  Including impredicative inductive types to the strong normalization
  model, on the other hand, does pose several technical challenges
  related to the realisability semantics.
  %
  \item As it is the case for most set-theoretic model constructions,
  one uses a notion of typed reduction.
  %
  Additionally, the strong normalization model does not include let
  statements or global or local contexts like \lang does.
  %
\end{itemize}

As a consequence of treating fixpoint recursors as binders for size
variables as in \eqref{eqn:new-fix}, when we reduce a fixpoint
recursor, we need to replace the corresponding bound size variable in
its body.
%
Work under some context $\Gamma$ and put as running example.
%
\begin{align*}
  F \triangleq \left\{\kw{fix}^\upsilon ~ f : \Nat^\upsilon \to \Nat^\upsilon \coloneqq e\right\}_{\hat{s}}
  \label{eqn:fix-example}\tag{$\varheartsuit$}
\end{align*}
%
Let $t$ be some $\Nat$ in constructor form where $t$ has size
$\hat{s}$.
%
Then, as fixpoint recursors bind size variables, when we apply $F$ to
$t$, we specialise $\upsilon$ to $\hat{s}$, so $\mu$-reduction should
say
%
\begin{align*}
  \app{F}{t} \rhd \app{\subst{\subst{e}{\upsilon}{s}}{f}{
  \left\{\kw{fix}^\upsilon ~ f : \Nat^\upsilon \to \Nat^\upsilon \coloneqq e\right\}_{s}
  }}{t}
  \label{eqn:mu-example}\tag{$\vardiamondsuit$}
\end{align*}
%
In particular, note that we substitute $s$ instead of $\hat{s}$ for
$\upsilon$ and we substitute for $f$ not $F$ but the fixpoint recursor
specialized to stage $s$.
%
This corresponds to the sized typing rule for fixpoint recursors:
$\left\{\kw{fix}^\upsilon ~ f : \Nat^\upsilon \to \Nat^\upsilon
  \coloneqq e\right\}_{s}$ is a function taking inputs of size $s$, so
on input $t$ of size $\hat{s}$, the body $e$ can recursively call
itself, but only on inputs of size $s$.

\subsubsection{Size-Irrelevance}
%
Via this model construction, the main lesson learnt is
that the intuition about how size types ensure termination by
restricting recursion on smaller elements is perhaps not quite so
straightforward to capture set-theoretically.

Take the situation of \eqref{eqn:fix-example} as example.
%
In the strong normalization model, we interpret terms and types as
their natural set-theoretic counterparts and size variables as
ordinals.
%
For $\rho$ a valuation of $\Gamma$ mapping variables to sets and $\pi$
mapping size variables to ordinals, denote by $\Val(M)_\rho^\pi$ the
set-theoretic denotation of the term $M$ under these valuations.
%
Now, suppose $s=\infty$ and consider how one would define
$\Val(F)_\rho^\pi$.
%
Since $s=\infty$, intuitively, $F$ should be the fixpoint of $e$.
%
So, we take some initial approximation of the fixpoint of the value of
$e$ and at every stage, improve the approximation by evaluating $e$ on
the prior approximation, until the approximation cannot be further
improved, which means we have reached a fixpoint of the iteration.

For the sake of simplicity, assume that for all ordinals $\alpha$, the
value of $\Nat^\upsilon$ where $\upsilon$ is interpreted as $\alpha$
is just
$\Val(\Nat^\upsilon)_\rho^{\subst{\pi}{\upsilon}{\alpha}} =
\McN^\alpha$ where $(\McN^\alpha)_\alpha$ is an $\subseteq$-increasing
family sets constant beyond $\omega$.
%
Putting $D_0$ to be some well-chosen singleton set and
$D_\alpha \triangleq \Val(\Nat^\upsilon \to
\Nat^\upsilon)_\rho^{\subst{\pi}{\upsilon}{\alpha}} = \McN^\alpha \to
\McN^\alpha$, the usual approach is to iterate up until the least
fixpoint of the operator
%
\begin{align*}
  \varphi \triangleq
  (\alpha \in \Ord) \mapsto (\psi \in D_\alpha) \mapsto \Val(e)_{\subst{\rho}{f}{\psi}}^{\subst{\pi}{\upsilon}{\alpha}}
  \tag{$e$-iter}\label{eqn:e-iter}
\end{align*}
%
starting from the initial approximation $\varphi_0 \in D_0$ and
setting the $(\alpha+1)$-th approximation $\varphi_{\alpha+1}$ as
$\varphi(\varphi_\alpha)$.
%
The typing rule for $F$ given by \refrule{fix-another} is sufficient
to ensure that each $\varphi_\alpha \in D_\alpha$.
%
However, this alone is not enough: we want the sequence
$(\varphi_\alpha)_\alpha$ to be convergent.

What would be a sufficient condition for convergence?
%
Note that $(\varphi_\alpha)_\alpha$ is obtained by successively
improving upon approximations of the fixpoint of $\varphi$, so one
would expect that
%
\begin{align*}
  \varphi_\alpha(x) = \varphi_\beta(x) \text{ for all } x \in \McN^\alpha \subseteq \McN^\beta
  \label{eqn:size-irrel}\tag{\textsc{size-irrel}}
\end{align*}
%
This expresses a condition of size-irrelevance: size variables bound
by fixpoint recursors can only be used to restrict their domains, and
should not be used to affect the value of computation.
%
And it turns out that \eqref{eqn:size-irrel} is enough to ensure
$(\varphi_\alpha)_\alpha$ converges to $\varphi_\omega$.
%
So, it remains to prove \eqref{eqn:size-irrel}.
%
Assume inductively it holds $\alpha,\beta$ and we would like to prove
it for $\alpha+1,\beta+1$, so that the goal is to show, for
$x \in \McN^{\alpha+1} \subseteq \McN^{\beta+1}$,
%
\begin{align*}
  \Val(e)_{\subst{\rho}{f}{\varphi_\alpha}}^{\subst{\pi}{\upsilon}{\alpha}}(x) =
  \Val(e)_{\subst{\rho}{f}{\varphi_\beta}}^{\subst{\pi}{\upsilon}{\beta}}(x)
\end{align*}
%
By the intuitive understanding of sized typing, on input
$x \in \McN^{\alpha+1}$ of size $\alpha+1$, the body $e$ can only
recursively call $f$ on inputs of size at most $\alpha$.
%
And inductively, $\varphi_\alpha$ behaves identically to
$\varphi_\beta$ on inputs of size at most $\alpha$.
%
So, $e$ on input $x \in \McN^{\alpha+1}$ should not be able to
distinguish between $\varphi_\alpha$ and $\varphi_\beta$, thus
ensuring the above equality.
%
However, just from \refrule{fix-another}, it seems that one cannot
easily conclude that $e$ cannot tell apart $\varphi_\alpha$ and
$\varphi_\beta$.

This problem was encountered also by \citet{barras-thesis}, who solved
it by introducing a special typing mode called size-irrelevance typing
and syntactic marker for the $\Pi$-types of fixpoint recursors.
%
We have used a similar solution to get around this problem in the
strong normalization proof of the alternative formulation of \lang.
%
However, in the size-irrelevance typing of \citet{barras-thesis},
there was the requirement that fixpoint recursors can never occur as
arguments to other functions in their defining body.
%
For example, in order for $e$ to pass size-irrelevance typing, $e$
cannot contain a sub-expression of the form $(\app{M}{f})$.
%
We were able to get rid of this requirement in the strong
normalization proof of this alternative formulation of \lang.
%
In fact, the typing rules allowed for size-irrelevance typing can be
expanded to include counterparts for almost all of the ``normal''
typing rules.

An alternative approach seems to be to use a model involving PERs,
where the PERs are designed to ensure size-irrelevance.
%
In any case, it seems that an inherent restriction of size-irrelevance
is one may not have a recursive function $F$ with behaviours such as
$\app{F}{n} \approx \Nat^\upsilon \to ...n\text{ times}... \to
\Nat^\upsilon$ or even $\app{F}{n} \approx \Nat^\upsilon$ where
$\upsilon$ is the size variable bound by $F$.
%
\citet{cic-hat-minus} has a similar restriction present in
\CIChatminus, and this restriction matches the intuition of
size-irrelevance.
%
If $\app{F}{n} \approx \Nat^\upsilon$ then the value of $F$ on an
input $n$ depends on the size $\upsilon$, which precisely the
behaviour size-irrelevance aims to forbid.
%
On the other hand, $\app{F}{n} \approx \Nat^\infty \to
...n\text{ times}...\to\Nat^\infty$ does adhere to size-irrelevance.

\subsubsection{Computation of $\infty$}
%
In the set-theoretic model, we also discovered that giving a
set-theoretic interpretation of the $\infty$ size was more technically
involved than one would expect.

Take the $\mu$-reduction equation in \eqref{eqn:mu-example} as an
example.
%
Once again, assume $s=\infty$ and \eqref{eqn:size-irrel} holds, so that
$(\varphi_\alpha)_\alpha$ is constant beyond $\omega$.
%
Then, by the previous discussion, the value of $F$ and of
$\left\{\kw{fix}^\upsilon ~ f : \Nat^\upsilon \to \Nat^\upsilon
  \coloneqq e\right\}_{s}$ are both taken to be
$\varphi_\omega = \varphi_{\kappa}$ for all $\kappa \geq \omega$.
%
Then, by substitutivity, the $\mu$-reduction equation in
\eqref{eqn:mu-example} should say, for sufficiently large
$\kappa \geq \omega$,
%
\begin{align*}
  \Val(\app{F}{t})_\rho^\pi =
  \Val(\app{\subst{\subst{e}{\upsilon}{\infty}}{f}{
  \left\{\kw{fix}^\upsilon ~ f : \Nat^\upsilon \to \Nat^\upsilon \coloneqq e\right\}_{\infty}
  }}{t})_\rho^\pi
\end{align*}
%
By substitutivity, this is equivalent to showing that
%
\begin{align*}
  \varphi_{\kappa+1}(\Val(t)_\rho^\pi) =
  \Val(\subst{e}{\upsilon}{\infty})_{\subst{\rho}{f}{\varphi_\kappa}}^{\pi}(\Val(t)_\rho^\pi)
\end{align*}
%
But
$\varphi_{\kappa+1} =
\Val(e)_{\subst{\rho}{f}{\varphi_\kappa}}^{\subst{\pi}{\upsilon}{\kappa}}$,
to show the above equality, it remains to move the
$\subst{e}{\nu}{\infty}$ in the syntax into the valuation
$\subst{\pi}{\nu}{\kappa}$, for some large $\kappa$.

More generally, it seems true that for all terms $M$ and valuations
$\rho$ and $\pi$, and size variables $\nu$, there is some ordinal
$\Infty(M;\nu)_\rho^\pi$ with the $\infty$-substitutivity property:
%
\begin{align*}
  \kappa \geq \Infty(M;\nu)_\rho^\pi \text{ implies }
  \Val(\subst{M}{\nu}{\infty})_\rho^\pi = \Val(M)_\rho^{\subst{\pi}{\nu}{\kappa}}
  \label{eqn:infty-subst}\tag{$\infty$-subst}
\end{align*}
%
This equality somehow expresses the idea that $\Infty(M;\nu)_\rho^\pi$
closes off all inductive types annotated with $\nu$ in $M$, so
$\Infty(M;\nu)_\rho^\pi$ is the denotation of $\infty$ for $\nu$ in
$M$ under $\rho$ and $\pi$.
%
Intuitively, we know this ordinal $\Infty(M;\nu)_\rho^\pi$ exists,
because the strict positivity condition ensures that by iterating the
operator associated with an inductive type up to its closure ordinal,
we eventually reach their fixpoints.
%
Since there can only be finitely many inductive types in $M$, an
ordinal with the $\infty$-substitutivity property is just the
supremum of these closure ordinals.

However, the computation of $\Infty(M;\nu)_\rho^\pi$ is complicated by
the fact that in $M$, the size variable $\nu$ can be annotated to more
than one inductive type.
%
For example, in $M$, the size variable $\nu$ can be annotated to both
$\Nat^\nu$ and $I^\nu$, where $I$ is some inductive type with a
different closure ordinal than $\Nat$.
%
In fact, it turned out that computing $\Infty(M;\nu)_\rho^\pi$ was
much more involved than initially expected.

\subsubsection{Relation to \lang and Coq}
%
Let us conclude this section by recalling that Coq itself is not
strongly normalizing, only weakly normalizing.
%
\footnote{At least, the
  underlying calculus is not. The counterexample ``normalizes'' to a
  stack overflow on machine with finite memory.}

\begin{minted}{coq}
Definition cbv_omega := fix f (n : nat) := let x := f n in O.
\end{minted}

This is a side-effect of relaxing the guard condition to enable more
sound programs to type check.
%
Ideally, sufficiently expressive sized typing will allow us to replace
the guard condition entirely and regain strong normalization in Coq.

However, an intermediate goal may be to achieve only weak
normalization of \lang.
%
This would also maintain backward compatibility with Coq, although it
is unclear if counterexamples like the above are ever desired in user
programs.

%%% Local Variables:
%%% TeX-master: "../main.tex"
%%% TeX-engine: default
%%% End:
