\section{\titlelang}\label{sec:typing}
In this section, we introduce and examine the syntax of \lang and various judgements,
culminating in the typing and well-formedness judgements.

\subsection{Syntax}

%We use the overline $\overline{\,\cdot\,}$ to denote a sequence of some construction.
%For instance, $\overline{\mathcal{V}}$ is a sequence of size variables $\mathcal{V} \dots \mathcal{V}$.

\input{figures/syntax.tex}

\autoref{fig:terms-general} presents the syntax of \lang,
with distinct size and term variables as well as \coinductive type names and \coinductive constructor names,
and terms $e$ annotated with size expressions $s$.
We use $m$ and $n$ as well as $i, j, k, \ell$ as metavariables for positive naturals used in indexing; note that we use 1-based indexing.
The overline $\overline{\,\ph\,}$ denotes a sequence of syntactic constructions often containing an index spanning some implicit range.
For instance, given $i$ inductive types, we write $\overline{I^{s_k}_k}$ to represent $I^{s_1}_1 \dots I^{s_i}_i$.
When a sequence is in brackets $\seq{\ph}$ or braces $\set{\ph}$,
the constructions are comma-separated for clarity.
For instance, the $j$ branches of a case expression are written as $\seq{\vec{c_\ell \Rightarrow e_\ell}}$ for $\seq{c_1 \Rightarrow e_1, \dots, c_j \Rightarrow e_j}$.

We reiterate the important differences present in \lang as compared to CIC and past work \CIChat and \CIChatminus:

\begin{itemize}
    \item \textbf{Inductive types} carry annotations that represent their size, \eg $\Nat^\upsilon$.
      This is the defining feature of sized types.
      They can also have position annotations, \eg $\Nat^*$, which mark the type as that of the recursive argument of a fixpoint or the return type of a cofixpoint, as well as other size-preserving types.
      This is similar to \texttt{struct} annotations in Coq that specify the structurally-recursive argument.
      \item \textbf{Definitions} are supported in the form of let expressions or as definitions in the global environment (defined further below),
      in constrast to \CIChat and \CIChatminus.
    \item \textbf{Variables} that are bound to definitions may have a \emph{size substitution} annotation, \eg $x^{\set{\upsilon_1 \mapsto s_1, \upsilon_2 \mapsto s_2}}$.
      The substitution is applied during reduction of the variable to the bound term.
      For instance, if $x$ is defined by $x : \Set \coloneqq \app{\List^{\upsilon_1}}{\Nat^{\upsilon_2}}$, then $x^{\set{\upsilon_1 \mapsto s_1, \upsilon_2 \mapsto s_2}}$ reduces to $\app{\List^{s_1}}{\const{Nat}^{s_2}}$.
    \item \textbf{Mutual \cofixpoints} are treated explicitly.
      In fixpoints, $n$ indicates the position of the recursive argument the fixpoint type, and $m$ picks out the $m$th \cofixpoint in the sequence of mutual definitions.
\end{itemize}

$e$ as defined above are called \textit{sized terms}.
We also have $e^*$ representing \textit{position terms},
where size annotations are either removed or replaced by $*$.
They are only found in the type annotations of fixpoints,
where terms like $\Nat^*$ might appear.
We discuss these annotations in more detail in \autoref{sec:typing:rules},
but in short, they mark the types that are \textit{size-preserving}.
On the other hand, $e^\circ$ represents \textit{bare terms},
where size annotations are removed entirely.
These come from \CIChatminus and \CIChat, and are necessary for subject reduction~\citep{cic-hat-minus}.
Finally, we use $e^\infty$ to denote \textit{full terms},
where $\infty$ is the \emph{only} size annotation in the term.

\input{figures/contexts.tex}

\autoref{fig:contexts} distinguishes between \textit{local} and \textit{global} environments, a distinction present in the Coq kernel.
Local assumptions and definitions occur in the bodies of functions and let expressions, respectively, while global ones are declared at the top level.
We use the same notation to represent sized, bare, and full environments,
so $\Delta^\infty$ for instance is a local declaration environment with only full terms.

\input{figures/sugar.tex}

\autoref{fig:sugar} defines syntactic sugar on terms, most of which is standard.

\subsubsection{Mutual (Co)Inductive Definitions}

\input{figures/inductives.tex}

The definition of mutual \coinductive types and their constructors are stored in a global signature $\Sigma$ as defined in \autoref{fig:inductives}.
A mutual \coinductive definition contains:

\begin{itemize}
    \item $\Delta_p$, the parameters of the \coinductive types and the constructors;
    \item $I_i$, the names of the \coinductive types;
    \item $\Delta_i$, the indices (or arguments) of $I_i$;
    \item $U_i$, the universe to which $I_i$ belongs;
    \item $c_j$, the names of the constructors;
    \item $\Delta_j$, the arguments of $c_j$;
    \item $I_j$, the \coinductive types of the fully-applied constructors; and
    \item $\overline{t}_j$, the indices of $I_j$.
\end{itemize}

Given a constructor $c_j$, we will often refer to $I_j$ as simply that constructor's inductive type.
Note that $I_j$ is \textit{not} the $j$th inductive type in the definition, but rather the specific inductive type associated with the $j$th constructor.
We would more precisely write $I_{k_j}$, to indicate that we pick out the $k_j$th inductive type, where the specific $k$ depends on $j$, but we forgo double subscript for clarity.

As an example, the usual $\const{Vector}$ type would be defined as (leaving out brackets for singleton sequences):
\begin{align*}
    \assm{\app{\Vector}{(A : \Type{})}&}{\Nat \to \Type{}} \coloneqq \\
        \seq{\assm{\VNil&}{\app{\Vector}{A}{\Zero}}, \\
        \assm{\VCons&}{(\assm{n}{\Nat}) \to A \to \app{\Vector}{A}{(\app{\Succ}{n}))}}}.
\end{align*}

As with mutual (co)\-fixpoints, we treat mutual \coinductive definitions explicitly.
Recall that in contrast to \CIChat and \CIChatminus, our definitions do not have a vector of polarities.
In those works, each parameter has an associated polarity that tells us whether the parameter is covariant, contravariant, or invariant with respect to the \coinductive type during subtyping.
Since Coq's \coinductive definitions do not have polarities, we forgo them for backward compatibility.
Consequently, we will see that the parameters of \coinductive types are always invariant in the subtyping \refrule{st-app}.

As usual, the well-formedness of \coinductive definitions depends on certain syntactic conditions such as strict positivity.
The conditions are reproduced in \autoref{sec:wf-ind}.
We refer the reader to clauses I1--I9 in \citet{cic-hat-minus}, clauses 1--7 in \mbox{\citet{cic-hat}}, and \citet{coq} for further details.
Generally, we can assume that non-nested \coinductive definitions that are valid in Coq are valid in \lang as well.
We further assume throughout that there is some implicit well-formed signature $\Sigma$ for every judgement.

Note that nested \coinductive types are \emph{not} supported in \lang, as they break subject reduction (see \autoref{sec:metatheory} for details).
This restriction manifests in the definition of strict positivity.

\subsubsection{Metafunctions and Metarelations}

We declare the following metafunctions, whose definitions are straightforward:

\begin{itemize}
    \item $\FV{\ph}, \SV{\ph}$ return the set of free term and size variables in a given term or environment, respectively;
    \item $\floor{\ph}$ returns the size variable a given finite (\ie not $\infty$) size expression;
    \item $\norm{\ph}$ returns the cardinality of its argument (\eg sequence length, set size, \etc);
    \item $\erase{\ph}$ erases sized terms to bare terms; and
    \item $\erase{\ph}^\upsilon$ replaces size annotations with size variable $\upsilon$ by $*$ and removes all other ones.
\end{itemize}

Note that the free size variables of a size substition $\rho$ are only those of the sizes that $\rho$ maps \emph{to}.

We use $t[x \coloneqq e]$ to denote the term $t$ with free variable $x$ substituted by expression $e$,
and $t[\upsilon \coloneqq s]$ to denote the term $t$ with size variable $\upsilon$ substituted by size expression $s$.
Furthermore, we use $\rho e$ to denote applying the size substitution $\rho$ to the term $e$.
That is, if $\upsilon \mapsto s$ is in $\rho$, then we perform the substitution $\subst{e}{\upsilon}{s}$.
$\rho s$ similarly does the same thing for the size expression $s$, and $\rho \Gamma$ for every term in the environment $\Gamma$.

Finally, $x \in \Gamma$, $(\assm{x}{t}) \in \Gamma$, or $(\defn{x}{t}{e}) \in \Gamma$ indicate that there is some declaration with variable name $x$, some assumption with type $t$, or some definition with type $t$ and body $e$ in the local context, respectively, and similarly for $\Gamma_G$.
\subsection{Reduction Rules}

The reduction rules listed in \autoref{fig:reduction} are the usual ones for CIC: $\beta$\=/reduction (function application), $\zeta$\=/reduction (let expression evaluation), $\iota$\=/reduction (case expressions), $\mu$\=/reduction (fixpoint expressions), $\nu$\=/reduction (cofixpoint expressions), $\delta$\=/reduction (local definitions), and $\Delta$\=/reduction (global definitions).
We define reduction ($\reduce$) as the congruent closure of the reductions,
multi-step reduction ($\rhd^*$) in \autoref{fig:reductions} as the reflexive--transitive closure of $\rhd$,
and convertibility ($\conv$, $\conv*$) in \autoref{fig:convertibility}.
Convertibility is divided into two judgements to take into account $\eta$-convertibility,
as is done informally in the Coq manual~\citep{coq} and formally in \citet{conversion}.
Note that there are no explicit rules for symmetry and transitivity of convertibility
because these properties are derivable, as proven in\opcitt{conversion}

\input{figures/reduction.tex}

In the case of \deltaDeltareduction, where the variable has a size substitution annotation, we modify the usual rules.
These reduction rules are important for supporting size inference with definitions.
If the definition body contains \coinductive types (or other defined variables), we can assign them fresh size variables for each distinct usage of the defined variable.
Further details are discussed in \autoref{sec:algorithm}.

We also use the metafunction \whnf to denote the reduction of a term to weak head normal form, which would have the form of a universe, a function type, an unapplied function, a \coinductive type (applied or unapplied), a constructor (applied or unapplied), an assumption variable (applied or unapplied), or an unapplied \cofixpoint, with arguments and inner terms unreduced.

\subsection{Subtyping Rules}\label{subsec:typing:subtyping}

\input{figures/subsizing.tex}

First, we define the subsizing relation in \autoref{fig:subsizing}.
Subsizing is straightforward since our size algebra is simple.
Note that we define $\succ{\infty}$ to be equal to $\infty$.

\input{figures/subtyping.tex}

We extend the usual subtyping for CIC to sized types in \autoref{fig:subtyping}.
The key features are:

\begin{itemize}
    \item Universes are \textbf{cumulative}. (\refnorule{st-cumul})
    \item Since convertibility is symmetric, if $t \conv* u$, then we have both $t \leq u$ and $u \leq t$. (\refnorule{st-conv})
    \item Inductive types are \textbf{covariant} in their size annotations; coinductive types are \textbf{contravariant}. (\refnorule{st-ind}, \refnorule{st-coind})
    \item The argument types of function types are \textbf{invariant}. (\refnorule{st-prod})
    \item The arguments of applications (and therefore the parameters and arguments of \coinductive types) are \textbf{invariant}. (\refnorule{st-app})
\end{itemize}

We can intuitively understand the covariance of inductive types by considering size annotations as a measure of the maximum number of constructors ``deep'' an object can be.
If a list has type $\List^s ~ t$, then a list with one more element can be said to have type $\List^{\hat{s}} ~ t$.
By the subsizing and subtyping rules, $\List^s ~ t \leq \List^{\hat{s}} ~ t$: if a list has at most $s$ ``many'' elements, then it certainly also has at most $\hat{s}$ ``many'' elements.

Conversely, for coinductive types, we can consider size annotations as a measure of how many constructors an object must at least ``produce''. A coinductive stream $\Stream^{\hat{s}}$ that produces at least $\hat{s}$ ``many'' elements can also produce at least $s$ ``many'' elements, so we have the contravariant relation $\Stream^{\hat{s}} \leq \Stream^s$.

Rules \refnorule{st-prod} and \refnorule{st-app} differ from \CIChat and \CIChatminus in their invariance, but correspond to CIC in Coq.
As previously mentioned, inductive definitions do not have polarities, so there is no way to indicate whether parameters are covariant, contravariant, or invariant.
As a compromise, we treat all parameters as invariant.
Note that, algorithmically speaking, the subtyping relation would produce \textit{both} subsizing constraints, and not \textit{neither}. For instance, $\List^{s_1} ~ \Nat^{s_3} \leq \List^{s_2} ~ \Nat^{s_4}$ yields $\Nat^{s_3} \conv* \Nat^{s_4}$, which yields both $s_3 \sqsubseteq s_4$ and $s_4 \sqsubseteq s_3$.
Further details on the subtyping algorithm are presented in \autoref{sec:algorithm}.

\subsection{Typing Rules}\label{sec:typing:rules}

We now present the typing rules of \lang.
Note that these are type checking rules for \textit{sized} terms, whose annotations come from size inference in \autoref{sec:algorithm}.

\input{figures/well-formed.tex}

We begin with the rules for well-formedness of local and global environments, presented in \autoref{fig:wf}.
As mentioned earlier, we elide the definition of well-formedness of signatures,
and assume that the ambient implicit signature is well-formed.

\input{figures/sets.tex}

\input{figures/metafunctions.tex}

\input{figures/pos-neg.tex}

\input{figures/typing.tex}

The typing rules for sized terms are given in \autoref{fig:typing}. As in CIC, we define the three sets \Axioms, \Rules, and \Elims in \autoref{fig:axruel}, which describe how universes are typed, how products are typed, and what eliminations are allowed in case expressions, respectively.
Metafunctions that construct some important function types are listed in \autoref{fig:metafunctions}; they are also used by the inference algorithm in \autoref{sec:algorithm}.
Finally, the typing rules use the notions of positivity and negativity, whose rules are given in \autoref{fig:posneg}, describing where the position annotations of fixpoints are allowed to appear.
Positivity and negativity are structured such that the properties $\upsilon \pos t \Leftrightarrow t \leq \subst{t}{\upsilon}{\hat{\upsilon}}$ and $\upsilon \neg t \Leftrightarrow \subst{t}{\upsilon}{\hat{\upsilon}} \leq t$ hold.

Rules \refnorule{var-assum}, \refnorule{const-assum}, \refnorule{univ}, \refnorule{conv} \refnorule{pi}, and \refnorule{app} are essentially unchanged from CIC.
Rules \refnorule{lam} and \refnorule{let} differ only in that type annotations are erased to bare.
This is to preserve subject reduction without requiring size substitution during reduction, and is discussed further by~\citet{cic-hat-minus}.

The first significant usage of size annotations are in Rules \refnorule{var-def} and \refnorule{const-def}.
If a variable or a constant is bound to a body in the local or global environment, it is annotated with a size substitution such that the body is well-typed after performing the substitution, allowing for proper $\delta$-/$\Delta$-reduction of variables and constants.
Notably, each usage of a variable or a constant does not have to have the same size annotations.

Before discussing typing \coinductive types, there are some indexing conventions to note.
In Rules \refnorule{ind}, \refnorule{constr}, and \refnorule{case}, we use $i$ to range over the number of \coinductive types in a single mutual \coinductive definition, $j$ to range over the number of constructors of a given \coinductive type, $k$ for a specific index in the range $\overline{\imath}$, and $\ell$ for a specific index in the range $\overline{\jmath}$.
In Rules \refnorule{fix} and \refnorule{cofix}, we use $k$ to range over the number of mutually-defined \cofixpoints and $m$ for a specific index in the range $\overline{k}$.
Finally, we use $\any$ (underscore) to omit irrelevant constructions for readability.

In \refrule{ind}, the type of a \coinductive type is a function type from its parameters $\Delta_p$ and its indices $\Delta_k$ to its universe $U_k$.
The \coinductive type itself holds a single size annotation.

In \refrule{constr}, the type of a constructor is a function type from its parameters $\Delta_p$ and its arguments $\Delta_\ell$ to its \coinductive type $I_\ell$ applied to the parameters and its indices $\overline{t}_\ell$.
Size annotations appear in two places:
\begin{itemize}
    \item In the argument types of the constructor.
      We annotate each occurrence of $I_\ell$ in $\Delta_\ell$ with a size expression $s$.
    \item On the \coinductive type of the fully-applied constructor.
      If the constructor belongs to the inductive type $I_\ell$, then it is annotated with the size expression $\hat{s}$.
      Using the successor guarantees that the constructor always constructs an object that is \textit{larger} than any of its arguments of the same type.
\end{itemize}
As an example, consider a possible typing of \text{VCons}:
\begin{align*}
\VCons &: (A: \Type{}) \to (n:\Nat^\infty) \to A \to \Vector^s ~ A ~ n \to \Vector^{\hat{s}} ~ A ~ (\Succ ~ n)
\end{align*}
It has a single parameter $A$ and $\Succ ~ n$ corresponds to the index $\overline{t}_j$ of the constructor's inductive type.
The input $\Vector$ has size $s$, while the output $\Vector$ has size $\hat{s}$.

In \refrule{case}, a case expression has three important parts:
\begin{itemize}
    \item The \textbf{target} $e$.
      It must have a \coinductive type $I_k$ with a successor size annotation $\hat{s}_k$ so that any constructor arguments of the same type can have the predecessor size annotation.

    \item The \textbf{motive} $P$.
      It is a function from the indices $\Delta_k$ of the target type $I_k$ and the target itself to the return type of the case expression.
      Note that in the motive's type in \autoref{fig:metafunctions}, the parameter variables $\dom{\Delta_p}$ in the indices are bound to the parameters of the target type.

      (This presentation follows CIC, but differs from that by~\citet{cic-hat-minus, cic-hat-l, cc-hat-omega}, where the case expression contains a return type in which the index and target variables are free and explicitly stated, in the syntactic form $\overline{y}.x.P$.)

    \item The \textbf{branches} $e_j$.
      Each branch is associated with a constructor $c_j$ and is a function over the arguments $\Delta_j$ of the constructor, producing some term.
      The type of each branch, listed in \autoref{fig:metafunctions}, is the motive $P$ applied to the indices $\overline{t}_j$ of that constructor's type and the constructor itself applied to the parameters and its arguments.

      Note that, like in the type of constructors, we annotate each occurence of $c_j$'s \coinductive type $I_k$ in $\Delta_j$ with the size expression $s$.
      The parameter variables in $\Delta_j$ and $\overline{t}_j$ are similarly bound to the parameters $\overline{p}$ of the target.
\end{itemize}

The type of the entire case expression is then the motive applied to the target type's indices and the target itself.
Notice that we also restrict the universe of this type based on the universe of the target type using \Elims.

Finally, we have the typing of mutual \cofixpoints in rules \refnorule{fix} and \refnorule{cofix}.
We take the annotated type $t_k$ of the $k$th \cofixpoint definition to be convertible to a function type containing a \coinductive type, as usual.
However, instead of the guard condition, we ensure termination/productivity using size expressions.

The main difficulty in these rules is supporting size preserving \cofixpoints.
We must restrict how the size variable $v_k$ appears in the type of the \cofixpoints, using the $\pos$ and $\neg$ judgments.
For fixpoints, the type of the $n_k$th argument, the recursive argument, is an inductive type annotated with a size variable $v_k$.
For cofixpoints, the return type is a coinductive type annotated with $v_k$.
The positivity or negativity of $v_k$ in the rest of $t_k$ indicate where $v_k$ may occur other than in the \corecursive position.
For instance, supposing that $n = 1$,
$\app{\List^\upsilon}{\Nat} \to \app{\List}{\Nat} \to \app{\List^\upsilon}{\Nat}$
is a valid fixpoint type with respect to $\upsilon$, while
$\app{\List^\upsilon}{\Nat} \to \app{\List^\upsilon}{\Nat} \to \app{\Stream^\upsilon}{\Nat}$
is not, since $\upsilon$ appears negatively in $\Stream$ and must not appear at all in the parameter of the second $\List$ argument type.
This is because $\upsilon_k$ indicates the types that are size-preserved.
For fixpoints, it indicates not only the recursive argument but also which return types have size \textit{at most} that of the recursive argument.
For cofixpoints, it indicates the arguments that have size \textit{at least} that of the return type.
Therefore, it cannot appear on types of the incorrect recursivity, or on types not being (co)\-recurred upon.

As in \refrule{lam}, we cannot keep the size annotations.
Instead, we mark \cofixpoint type annotations, which recall are position terms,
as size-preserving using the erasure $|t_k|^{\upsilon_k}$ to replace size
annotations in $t_k$ whose size variable is $\upsilon_k$ with $*$.

Checking termination and productivity is relatively straightforward.
If $t_k$ are well typed, then the \cofixpoint bodies should have type $t_k$ with a successor size in the local context where \cofixpoint names $f_k$ are bound to their types $t_k$.
Intuitively, this tells us that the recursive calls to $f_k$ in fixpoint bodies are on smaller-sized arguments, and that corecursive bodies produce objects larger than those from the corecursive call to $f_k$.
The type of the whole \cofixpoint is then the $m$th type $t_m$ with its size variable $v_m$ bound to some size expression $s$.

In Coq, the indices of the recursive elements are rarely given, and there are no user-provided position annotations at all.
In \autoref{sec:algorithm}, we present how we compute the indices and the position annotations during size inference.

%%% Local Variables:
%%% TeX-master: "../main.tex"
%%% TeX-engine: default
%%% End:
