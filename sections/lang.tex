\section{\titlelang}\label{sec:typing}
In this section, we present \lang, a core calculus for sized typing in Coq.

\subsection{Syntax}

%We use the overline $\overline{\,\cdot\,}$ to denote a sequence of some construction.
%For instance, $\overline{\mathcal{V}}$ is a sequence of size variables $\mathcal{V} \dots \mathcal{V}$.

\input{figures/terms-general.tex}

\autoref{fig:terms-general} presents the syntax of \lang,
with distinct size and term variables as well as \coinductive type names and \coinductive constructor names,
and terms $e$ annotated with size expressions $s$.
We use $m$ and $n$ as well as $i, j, k, \ell$ as metavariables for positive naturals used in indexing; note that we use 1-based indexing.
The brackets $\seq{\ph}$ delimit a sequence of comma-separated syntactic constructions.
For instance, the branches of a case expression for an inductive type with two constructors would be written as $\seq{c_1 \Rightarrow e_1, c_2 \Rightarrow e_2}$.
The overline $\overline{\,\ph\,}$ denotes a sequence of syntactic constructions often containing an index spanning some implicit range.
For instance, given $i$ inductive types, we write $\overline{I^{s_k}_k}$ to represent $I^{s_1}_1 \dots I^{s_i}_i$.
We do the same for the brackets, so that given a case expression with $j$ branches for example, we write $\seq{c_\ell \Rightarrow e_\ell}$ for $\seq{c_1 \Rightarrow e_1, \dots, c_j \Rightarrow e_j}$.


\lang resembles the usual CIC, but there are some important differences compared to CIC and compared to past work \CIChat and \CIChatminus:

\begin{itemize}
    \item \textbf{Inductive types} carry annotations that represent their size, \eg $\Nat^\upsilon$.
      This is the defining feature of sized types.
      They can also have position annotations, \eg $\Nat^*$, which mark the type as that of the recursive argument of a fixpoint or the return type of a cofixpoint, as well as other size-preserving types.
      This is similar to \texttt{struct} annotations in Coq that specify the structurally-recursive argument.
    \item \textbf{Variables} may have a vector of annotations, \eg $x^{\seq{\upsilon_1, \upsilon_2}}$.
      If the variable is bound to a term containing \coinductive types, we assign the annotations to each \coinductive type during reduction.
      For instance, if $x$ is defined by $x : \Set \coloneqq \app{\List}{\Nat}$, then $x^{\seq{\upsilon_1, \upsilon_2}}$ reduces to $\app{\List^{\upsilon_1}}{\const{Nat}^{\upsilon_2}}$.
    \item \textbf{Definitions} are supported, in constrast to \CIChat and \CIChatminus. This reflects the actual structure in Coq's kernel.
    \item \textbf{Mutual \cofixpoints} are treated explicitly.
      In fixpoints, $\seq{n_k}$ is a vector of indices indicating the positions of the recursive arguments in each fixpoint type, and $m$ picks out the $m$th \cofixpoint in the vector of mutual definitions.
\end{itemize}

$e$ as defined above are called \textit{sized terms}.
We also have $e^*$ representing \textit{position terms},
where size annotations are either removed or replaced by $*$.
They are only found in the type annotations of fixpoints,
where terms like $\Nat^*$ might appear.
We discuss these annotations in more detail in \autoref{sec:typing:rules},
but in short, they mark the types that are \textit{size-preserving}.
On the other hand, $e^\circ$ represents \textit{bare terms},
where size annotations are removed entirely.
These come from \CIChatminus and \CIChat, and are necessary for subject reduction~\citep{cic-hat-minus}.
Finally, we use $e^\infty$ to denote \textit{full terms},
where $\infty$ is the \emph{only} size annotation in the term.

\input{figures/contexts.tex}

\autoref{fig:contexts} distinguishes between \textit{local} and \textit{global} environments, a distinction present in the Coq kernel.
Local assumptions and definitions occur in the bodies of functions and let expressions, respectively, while global ones are declared at the top level.
We use the same notation to represent sized, bare, and full environments,
so $\Delta^\infty$ for instance is a local declaration environment with only full terms.

\input{figures/sugar.tex}

\autoref{fig:sugar} defines syntactic sugar on terms, most of which is standard.

We use $t[x \coloneqq e]$ to denote the term $t$ with free variable $x$ substituted by expression $e$, and $t[\upsilon \coloneqq s]$ to denote the term $t$ with size variable $\upsilon$ substituted by size expression $s$.
Additionally, we use $t\overline{[\infty_i \coloneqq s_i]}$ to denote the substitutions of all $\infty$ annotations in $t$ by the size expressions $\overline{s_i}$ in left-to-right order.
The substitution is valid only if the number of $\infty$ annotations in $t$ is same as the length of $\overline{s_i}$.

\subsubsection{Mutual (Co)Inductive Definitions}

\input{figures/inductives.tex}

The definition of mutual \coinductive types and their constructors are stored in a global signature $\Sigma$ as defined in \autoref{fig:inductives}.
(Typing judgements are parameterized by all three of $\Sigma, \Gamma_G, \Gamma$.)
A mutual \coinductive definition contains:

\begin{itemize}
    \item $\Delta_p$, the parameters of the \coinductive types and the constructors;
    \item $I_i$, the names of the \coinductive types;
    \item $\Delta_i$, the indices (or arguments) of $I_i$;
    \item $U_i$, the universe to which $I_i$ belongs;
    \item $c_j$, the names of the constructors;
    \item $\Delta_j$, the arguments of $c_j$;
    \item $I_j$, the \coinductive types of the fully-applied constructors; and
    \item $\overline{t}_j$, the indices of $I_j$.
\end{itemize}

Given a constructor $c_j$, we will often refer to $I_j$ as simply that constructor's inductive type.
Note that $I_j$ is \textit{not} the $j$th inductive type in the definition, but rather the specific inductive type associated with the $j$th constructor.
We would more precisely write $I_{k_j}$, to indicate that we pick out the $k_j$th inductive type, where the specific $k$ depends on $j$, but we forgo double subscript for clarity.

As an example, the usual $\const{Vector}$ type would be defined in the language as:
\begin{align*}
    \assm{\app{\Vector}{(A : \Type{})}&}{\Nat \to \Type{}} \coloneqq \\
        \seq{\assm{\VNil&}{\app{\Vector}{A}{\Zero}}, \\
        \assm{\VCons&}{(\assm{n}{\Nat}) \to A \to \app{\Vector}{A}{(\app{\S}{n}))}}}.
\end{align*}

As with mutual (co)\-fixpoints, we treat mutual \coinductive definitions explicitly.
Furthermore, in contrast to \CIChat and \CIChatminus, our definitions do not have a vector of polarities.
In those works, each parameter has an associated polarity that tells us whether the parameter is covariant, contravariant, or invariant with respect to the \coinductive type during subtyping.
Since Coq's \coinductive definitions do not have polarities, we forgo them so that our type checker can work with existing Coq code without modification.
Consequently, we will see that the parameters of \coinductive types are always invariant in the subtyping \refrule{st-app}.

As usual, the well-formedness of \coinductive definitions depends on certain syntactic conditions such as strict positivity.
The conditions are defined in \anotherpdf and reproduced in \autoref{sec:wf-ind}.
We refer the reader to clauses I1--I9 in \citet{cic-hat-minus}, clauses 1--7 in \mbox{\citet{cic-hat}}, and \citet{coq} for further details.
Generally, we can assume that non-nested \coinductive definitions that are valid in Coq are valid in \lang as well.

Note that nested \coinductive types are \emph{not} supported in \lang, as they break subject reduction (see \autoref{sec:metatheory} for details).
This restriction manifests in the definition of strict positivity.

\subsubsection{Metafunctions}

We declare the following metafunctions:

\begin{itemize}
    \item $\FV{\ph}, \SV{\ph}$ return the set of free term and size variables in a given term;
    \item $\floor{\ph}$ returns the size variable a given finite (\ie not $\infty$) size expression;
    \item $\norm{\ph}$ returns the cardinality of its argument (\eg sequence length, set size, \etc);
    \item $\svs{\ph}$ counts the number of size annotations in the given term;
    \item $\erase{\ph}$ erases sized terms to bare terms;
    \item $\erase{\ph}^\infty$ replaces all sizes by $\infty$; and
    \item $\erase{\ph}^\upsilon: T \to T^*$ replaces size annotations $\upsilon$ by $*$ removes all other ones.
\end{itemize}

Their definitions are straightforward.
Metafunctions on sized terms are inductive on their structure, and do not touch recursive bare and position terms.

We use the following additional expressions relating membership in contexts and signatures:

\begin{itemize}
    \item $x \in \Gamma$, $\assm{x}{t} \in \Gamma$, or $\defn{x}{t}{e} \in \Gamma$ indicate that there is some declaration with variable name $x$, some assumption with type $t$, or some definition with type $t$ and body $e$ in the local context, and similarly for $\Gamma_G$;
    \item $\Gamma(x)$ returns the type (and possibly body) bound to $x$ in $\Gamma$, and similarly for $\Gamma_G$;
    \item $I \in \Sigma$ means the \coinductive definition of type $I$ is in the signature.
\end{itemize}

\subsection{Reduction Rules}

The reduction rules are the usual ones for CIC: $\beta$\=/reduction (function application), $\zeta$\=/reduction (let expression evaluation), $\iota$\=/reduction (case expressions), $\mu$\=/reduction (fixpoint expressions), $\nu$\=/reduction (cofixpoint expressions), $\delta$\=/reduction (local definitions), and $\Delta$\=/reduction (global definitions).
We define convertibility ($\approx$) as the symmetric--reflexive--transitive compatible closure of reductions up to $\eta$-expansion.
The complete reduction rules are reproduced in \autoref{sec:red-conv-trans};
we refer the reader to previous work~\citep{cic-hat-minus, cic-hat, cc-hat-omega} and the Coq manual in particular~\citet{coq} for precise details and definitions.

\input{figures/reduction.tex}

In the case of \deltaDeltareduction, if the variable has a vector of annotations, we define additional rules, shown in \autoref{fig:reduction}.
These reduction rules are important for supporting size inference with definitions.
If the definition body contains \coinductive types (or other defined variables), we can assign them fresh annotations for each distinct usage of the defined variable.
This ensures that certain subsizing relations are not lost due to the erasure of definition bodies.
Further details are discussed in later sections.

We also use the metafunction \whnf to denote the reduction of a term to weak head normal form, which would have the form of a universe, a function type, an unapplied function, a \coinductive type (applied or unapplied), a constructor (applied or unapplied), an assumption variable (applied or unapplied), or an unapplied \cofixpoint, with arguments and inner terms unreduced.

\subsection{Subtyping Rules}\label{subsec:typing:subtyping}

\input{figures/subsizing.tex}

First, we define the subsizing relation in \autoref{fig:subsizing}.
Subsizing is straightforward since our size algebra is simple.
Note that we define $\succ{\infty}$ to be equal to $\infty$.

\input{figures/subtyping.tex}

We extend the usual subtyping for CIC to sized types in \autoref{fig:subtyping}.
The key features are:

\begin{itemize}
    \item Universes are \textbf{cumulative}. (\refnorule{st-cumul})
    \item Since convertibility is symmetric, if $t \approx u$, then we have both $t \leq u$ and $u \leq t$. (\refnorule{st-conv})
    \item Inductive types are \textbf{covariant} in their size annotations; coinductive types are \textbf{contravariant}. (\refnorule{st-ind}, \refnorule{st-coind})
    \item The argument types of function types are \textbf{invariant}. (\refnorule{st-prod})
    \item The arguments of applications (and therefore the parameters and arguments of \coinductive types) are \textbf{invariant}. (\refnorule{st-app})
\end{itemize}

We can intuitively understand the covariance of inductive types by considering size annotations as a measure of the maximum number of constructors ``deep'' an object can be.
If a list has type $\List^s ~ t$, then a list with one more element can be said to have type $\List^{\hat{s}} ~ t$.
By the subsizing and subtyping rules, $\List^s ~ t \leq \List^{\hat{s}} ~ t$: if a list has at most $s$ ``many'' elements, then it certainly also has at most $\hat{s}$ ``many'' elements.

Conversely, for coinductive types, we can consider size annotations as a measure of how many constructors an object must at least ``produce''. A coinductive stream $\Stream^{\hat{s}}$ that produces at least $\hat{s}$ ``many'' elements can also produce at least $s$ ``many'' elements, so we have the contravariant relation $\Stream^{\hat{s}} \leq \Stream^s$.

Rules \refnorule{st-prod} and \refnorule{st-app} differ from \CIChat and \CIChatminus in their invariance, but correspond to CIC in Coq.
As previously mentioned, inductive definitions do not have polarities, so there is no way to indicate whether parameters are covariant, contravariant, or invariant.
As a compromise, we treat all parameters as invariant.
Note that, algorithmically speaking, the subtyping relation would produce \textit{both} subsizing constraints, and not \textit{neither}. For instance, $\List^{s_1} ~ \Nat^{s_3} \leq \List^{s_2} ~ \Nat^{s_4}$ yields $\Nat^{s_3} \approx \Nat^{s_4}$, which yields both $s_3 \sqsubseteq s_4$ and $s_4 \sqsubseteq s_3$.
Further details on the subtyping algorithm are presented in \autoref{sec:algorithm}.

\subsection{Typing Rules}\label{sec:typing:rules}

We now present the typing rules of \lang.
Note that these are type checking rules for \textit{sized} terms, whose annotations come from size inference in \autoref{sec:algorithm}.

\input{figures/well-formed.tex}

We begin with the rules for well-formedness of local and global environments, presented in \autoref{fig:wf}.
As mentioned earlier, we elide the well-formedness of signatures.

\input{figures/metafunctions.tex}

\input{figures/pos-neg.tex}

\input{figures/typing.tex}

The typing rules for sized terms are given in \autoref{fig:typing}. As in CIC, we define the three sets \Axioms, \Rules, and \Elims, which describe how universes are typed, how products are typed, and what eliminations are allowed in case expressions, respectively.
These are listed in \autoref{fig:axruel} in \autoref{sec:supplementary}.
Metafunctions that construct some important function types are listed in \autoref{fig:metafunctions}; they are also used by the inference algorithm in \autoref{sec:algorithm}.
Finally, the typing rules use the notions of positivity and negativity, whose rules are given in \autoref{fig:posneg}, describing where the position annotations of fixpoints are allowed to appear.
Positivity and negativity are structured such that the properties $\upsilon \pos t \Leftrightarrow t \leq \subst{t}{\upsilon}{\hat{\upsilon}}$ and $\upsilon \neg t \Leftrightarrow \subst{t}{\upsilon}{\hat{\upsilon}} \leq t$ hold.

Rules \refnorule{var-assum}, \refnorule{const-assum}, \refnorule{univ}, \refnorule{conv} \refnorule{pi}, and \refnorule{app} are essentially unchanged from CIC.
Rules \refnorule{lam} and \refnorule{let} differ only in that type annotations are erased to bare.
This is to preserve subject reduction without requiring size substitution during reduction, and is discussed further by~\citet{cic-hat-minus}.

The first significant usage of size annotations are in Rules \refnorule{var-def} and \refnorule{const-def}.
If a variable or a constant is bound to a body in the local or global environment, it is annotated with a vector of size expressions such that the body is well-typed after substituting in those size expressions, allowing for proper $\delta$-/$\Delta$-reduction of variables and constants.
Note that each usage of a variable or a constant does not have to have the same size annotations.
Furthermore, every global annotation in a constant's type is instantiated to the same size expression $s$, which enforces size-preservedness.

Before discussing typing \coinductive types, there are some indexing conventions to note.
In Rules \refnorule{ind}, \refnorule{constr}, and \refnorule{case}, we use $i$ to range over the number of \coinductive types in a single mutual \coinductive definition, $j$ to range over the number of constructors of a given \coinductive type, $k$ for a specific index in the range $\overline{\imath}$, and $\ell$ for a specific index in the range $\overline{\jmath}$.
In Rules \refnorule{fix} and \refnorule{cofix}, we use $k$ to range over the number of mutually-defined \cofixpoints and $m$ for a specific index in the range $\overline{k}$.
Finally, we use $\any$ (underscore) to omit irrelevant constructions for readability.

In \refrule{ind}, the type of a \coinductive type is a function type from its parameters $\Delta_p$ and its indices $\Delta_k$ to its universe $U_k$.
The \coinductive type itself holds a single size annotation.

In \refrule{constr}, the type of a constructor is a function type from its parameters $\Delta_p$ and its arguments $\Delta_\ell$ to its \coinductive type $I_\ell$ applied to the parameters and its indices $\overline{t}_\ell$.
Size annotations appear in two places:
\begin{itemize}
    \item In the argument types of the constructor.
      We annotate each occurrence of $I_\ell$ in $\Delta_\ell$ with a size expression $s$.
    \item On the \coinductive type of the fully-applied constructor.
      If the constructor belongs to the inductive type $I_\ell$, then it is annotated with the size expression $\hat{s}$.
      Using the successor guarantees that the constructor always constructs an object that is \textit{larger} than any of its arguments of the same type.
\end{itemize}
As an example, consider a possible typing of \text{VCons}:
\begin{align*}
\VCons &: (A: \Type{}) \to (n:\Nat^\infty) \to A \to \Vector^s ~ A ~ n \to \Vector^{\hat{s}} ~ A ~ (\Succ ~ n)
\end{align*}
It has a single parameter $A$ and $\Succ ~ n$ corresponds to the index $\overline{t}_j$ of the constructor's inductive type.
The input $\Vector$ has size $s$, while the output $\Vector$ has size $\hat{s}$.

In \refrule{case}, a case expression has three important parts:
\begin{itemize}
    \item The \textbf{target} $e$.
      It must have a \coinductive type $I_k$ with a successor size annotation $\hat{s}_k$ so that any constructor arguments of the same type can have the predecessor size annotation.

    \item The \textbf{motive} $P$.
      It is a function from the indices $\Delta_k$ of the target type $I_k$ and the target itself to the return type of the case expression.
      Note that in the motive's type in \autoref{fig:metafunctions}, the parameter variables $\dom{\Delta_p}$ in the indices are bound to the parameters of the target type.

      (This presentation follows CIC, but differs from that by~\citet{cic-hat-minus, cic-hat-l, cc-hat-omega}, where the case expression contains a return type in which the index and target variables are free and explicitly stated, in the syntactic form $\overline{y}.x.P$.)

    \item The \textbf{branches} $e_j$.
      Each branch is associated with a constructor $c_j$ and is a function over the arguments $\Delta_j$ of the constructor, producing some term.
      The type of each branch, listed in \autoref{fig:metafunctions}, is the motive $P$ applied to the indices $\overline{t}_j$ of that constructor's type and the constructor itself applied to the parameters and its arguments.

      Note that, like in the type of constructors, we annotate each occurence of $c_j$'s \coinductive type $I_k$ in $\Delta_j$ with the size expression $s$.
      The parameter variables in $\Delta_j$ and $\overline{t}_j$ are similarly bound to the parameters $\overline{p}$ of the target.
\end{itemize}

The type of the entire case expression is then the motive applied to the target type's indices and the target itself.
Notice that we also restrict the universe of this type based on the universe of the target type using \Elims.

Finally, we have the typing of mutual \cofixpoints in rules \refnorule{fix} and \refnorule{cofix}.
We take the annotated type $t_k$ of the $k$th \cofixpoint definition to be convertible to a function type containing a \coinductive type, as usual.
However, instead of the guard condition, we ensure termination/productivity using size expressions.

The main difficulty in these rules is supporting size preserving \cofixpoints.
We must restrict how the size variable $v_k$ appears in the type of the \cofixpoints, using the $\pos$ and $\neg$ judgments.
For fixpoints, the type of the $n_k$th argument, the recursive argument, is an inductive type annotated with a size variable $v_k$.
For cofixpoints, the return type is a coinductive type annotated with $v_k$.
The positivity or negativity of $v_k$ in the rest of $t_k$ indicate where $v_k$ may occur other than in the \corecursive position.
For instance, supposing that $n = 1$,
$\app{\List^\upsilon}{\Nat} \to \app{\List}{\Nat} \to \app{\List^\upsilon}{\Nat}$
is a valid fixpoint type with respect to $\upsilon$, while
$\app{\List^\upsilon}{\Nat} \to \app{\List^\upsilon}{\Nat} \to \app{\Stream^\upsilon}{\Nat}$
is not, since $\upsilon$ appears negatively in $\Stream$ and must not appear at all in the parameter of the second $\List$ argument type.
This is because $\upsilon_k$ indicates the types that are size-preserved.
For fixpoints, it indicates not only the recursive argument but also which return types have size \textit{at most} that of the recursive argument.
For cofixpoints, it indicates the arguments that have size \textit{at least} that of the return type.
Therefore, it cannot appear on types of the incorrect recursivity, or on types not being (co)\-recurred upon.

As in \refrule{lam}, we cannot keep the size annotations.
Instead, we mark \cofixpoint type annotations, which recall are position terms,
as size-preserving using the erasure $|t_k|^{\upsilon_k}$ to replace size
annotations in $t_k$ whose size variable is $\upsilon_k$ with $*$.

Checking termination and productivity is relatively straightforward.
If $t_k$ are well typed, then the \cofixpoint bodies should have type $t_k$ with a successor size in the local context where \cofixpoint names $f_k$ are bound to their types $t_k$.
Intuitively, this tells us that the recursive calls to $f_k$ in fixpoint bodies are on smaller-sized arguments, and that corecursive bodies produce objects larger than those from the corecursive call to $f_k$.
The type of the whole \cofixpoint is then the $m$th type $t_m$ with its size variable $v_m$ bound to some size expression $s$.

In Coq, the indices of the recursive elements are rarely given, and there are no user-provided position annotations at all.
In \autoref{sec:algorithm}, we present how we compute the indices and the position annotations during size inference.
