\section{Related Work}\label{sec:related}

This work is based on \CIChat~\cite{cic-hat}, which describes CIC with sized types and a size inference algorithm.
It assumes that position annotations are given by the user, requires each parameter of \coinductive types to be assigned polarities, and deals only with terms.
We have added on top of it global declarations, local definitions, constants and variables annotated by a vector of size expressions, their \deltaDeltareductions, an explicit treatment of mutually-defined \coinductive types and \cofixpoints, and an intermediate procedure \RecCheckLoop to handle missing position annotations, while removing parameter polarities and subtyping rules based on these polarities.

The language \CIChatminus~\cite{cic-hat-minus} is similar to \CIChat, described in greater detail, but with one major difference: \CIChatminus disallows size variables in the bodies of abstractions, in the arguments of applications, and in case expression branches, making \CIChatminus a strict subset of \CIChat.
Any size expressions found in these locations must be set to $\infty$.
This ``solves'' the problem discussed in \autoref{sec:sponge-cake} of how to handle defined variables used in \cofixpoints by disallowing it entirely.
In practice, such as in Coq's standard library, aliases are often defined for \coinductive types, so we designed \lang to accommodate \cofixpoints defined over aliases and other type-level computations.

The implementation of \RecCheck comes from \Fhat~\cite{f-hat}, an extension of System F with type-based termination using sized types.
Rules relating to coinductive constructions and cofixpoints come from the natural extension of \CChatomega~\cite{cc-hat-omega}, which describes only infinite streams.
The size inference algorithm is based on those of \CIChat, \CChatomega, and \CIChatl~\cite{cic-hat-l}.

Whereas our size algebra supports only a successor operation, \emph{linear} sized types in \CIChatl extends the algebra by including size expressions of the form $n \cdot S$, so that all annotations are of the form $n \cdot \upsilon + m$, where $m$ is the number of ``hats''.
Unfortunately, this causes the time complexity of its \RecCheck procedure to be worst-case doubly exponential in the number of size variables.
However, the set of typeable (and therefore terminating or productive) functions is expanded compared to \lang; functions such as list-doubling could be typed as size-preserving in addition to being terminating.
If successor sized types prove practical, augmenting the type system to linear sized types would be worth investigating, depending on whether common programs would cause worst-case behaviour.
The most significant change required would be in \RecCheck, which must then solve a set of constraints in Presburger arithmetic.

Well-founded sized types in \CIChatsub~\cite{wellfounded} are yet another extension of successor sized types.
The unpublished manuscript contains a type system, some metatheoretical results, and a size inference algorithm.
In essence, it preserves subject reduction for coinductive constructions, and also expands the set of typeable functions.

\input{figures/agda-size.tex}

The proof assistant Agda implements sized types as user-provided size parameters, similar to type parameters.
Correspondingly, sizes have the type Size, while Size itself has the type SizeUniv, which is its own type. \autoref{fig:agda-size} presents the typing rules for Size; the operator $\uparrow \cdot$ corresponds to our $\hat{\cdot}$, while $\cdot \sqcup^s \cdot$ takes the maximum of two sizes.
Additionally, Agda defines the size constructor Size<, which allows the user to specify a size constraint $r \sqsubseteq s$ with the annotation $r: \text{Size<} s$.
Whereas CIC$\widehat{~}\,$'s philosophy is to hide all size annotations from the user with a focus on size inference, Agda opts for allowing users to explicitly write size annotations and treat them almost like terms, yielding greater flexibility in deciding how things should be typed.
However, this approach is a non-starter if we wish to maintain backward compatibility with Coq.
