\section{Overview}\label{sec:overview}
% Maybe this is more of an in-depth "related work" than an overview?

As mentioned, \lang is an extension of \CIChat and \CIChatminus.
These add sized types to CIC with the explicit philosophy of requiring no size annotations:
a user would write bare CIC code, and the type checker would have the simultaneous task of inferring all the size annotations.
However, Coq's core calculus extends quite a bit beyond merely CIC,
and the presentation of various analogous features differ subtly but nontrivially.
The goal of \lang is to bring sized types in CIC a few steps closer to Coq,
while keeping with the original philosphy.
In the process of conforming to Coq's calculus, to minimize the changes required to it so that a prototype implementation is viable
--- for Coq's codebase itself is old, large, and intricate ---
we must also discard some features from \CIChatminus.
In this section, we discuss what \lang has added or removed relative to past work and to Coq,
and their implications on the metatheory and the implementation.

\subsection{Commonalities and Minor Additions}

\lang and \CIChatminus are both extensions of CIC, with dependent functions, a universe hierarchy, inductive definitions, case expressions, and fixpoints.
\lang adds coinductive definitions and cofixpoints, as well as mutually-defined \coinductives and \cofixpoints.
It also adds universe cumulativity and an impredicative $\Prop$ universe,
but not universe polymorphism or a strict $\Prop$,
which are beyond our scope;
all four of these are existing features of Coq.
Cumulativity and impredicativity complicate the set-theoretic model by \citet{cic-hat-minus}, but these issues are known: see, for instance, \citet{not-so-simple-cc}.

In terms of sized types, \lang and \CIChatminus add to CIC size expressions as annotations to \coinductive types,
and a \cofixpoint $f$ is well-typed if all \corecursive calls in its body occurs on an argument of a smaller size,
as we have seen with the simplified typing rule in \autoref{sec:intro}.
Constructors construct constructions of a larger size than their \corecursive arguments.
Important to note is that size variables are not explicitly bound anywhere, and are effectively global.
For instance, $\Nat^{\upsilon_1} \rightarrow \Nat^\infty \rightarrow \Nat^{\succ{\upsilon}_2}$ is a valid (and well-typed) term in an empty environment, with no relation between the sizes $\upsilon_1$ and $\succ{\upsilon}_2$.

Sizes may be related to one another by a subsizing relation, which is a reflexive partial order on sizes,
with $s \sqsubseteq \succ{s}$ and the $\infty$ size being greater than all sizes.
The subsizing relation extends subtyping by inducing a covariant subtyping relation on inductive types and a contravariant one on coinductive types; that is,
if $r \sqsubseteq s$ and $I$ is inductive, then $I^r \leq I^s$,
and if $I$ is coinductive, then $I^s \leq I^r$.
We examine the syntax and judgements of \lang in detail in \autoref{sec:typing}.

\subsection{Definitions}

Coq's core calculus contains two types of variables:%
\footnote{It also has a third type of variable for section-level bindings;
this is beyond the scope of \lang.}
one for local bindings from functions, function types, and let expressions,
and one for global bindings from vernacular declarations such as \coqinline{Definition} and \coqinline{Parameter} (which we call \textit{constants}).
\lang adds let expressions and global declarations to \CIChatminus,
with separate local and global environments,
and definitions in the environments in the style of a PTS with definitions~\citep[233--241]{pts}.

Global definitions and let expressions let us define aliases for types for concision and organization of code,
which necessitates a form of size polymorphism if we want the aliases to behave as we expect.
For instance, if we globally define $\Defn{N}{\Type{}}{\Nat^\upsilon}$,
and later want to define an addition function with type $N \rightarrow N \rightarrow N$,
it would \emph{not} be correct to perform the na\"ive substitution to get $\Nat^\upsilon \rightarrow \Nat^\upsilon \rightarrow \Nat^\upsilon$:
addition intuitively does not always return something of the same size.

What we want instead is to allow a different size for each use of $N$,
allowing the above type to reduce to $\Nat^{\upsilon_1} \rightarrow \Nat^{\upsilon_2} \rightarrow \Nat^{\upsilon_3}$.
This means $N$ must be polymorphic in the sizes involved in its definition,
the same kind of rank-1 or prenex polymorphism in ML-style let polymorphism for type variables.
To retain backward compatibility, there is no explicit size quantification ---
every definition and let binding is implicitly quantified over \emph{all} size variables involved.
The corresponding notion of size instantiation comes in the form of size substitution annotations on variables and constants, so that $N^{\set{\upsilon \mapsto s}}$ for instance reduces to $\Nat^s$.
These and all other size annotations are inferrable, as detailed in \autoref{sec:algorithm}.

Having definitions and annotated variables and constants also means we need to allow sizes to appear
not only in the bodies of let expressions but also in the bodies of functions and in the branches of case expressions,
in contrast to \CIChatminus.
% TODO: Ask Michael about the consequences of this on normalization.

\paragraph*{} While \CIChat's size inference algorithm takes a local environment and an unannotated term
and returns a size-annotate term and its type along with a set of constraints on their size annotations,
we need to handle inference of global declarations.
Left with a constraint set after inference of a definition's body, we have two options:
attach the constraints to the definition in the environment,
or ``solve'' the constraints by reassigning size variables with sizes that satisfy those constraints.
Global definitions in Coq are relatively independent in terms of type checking,
so we choose the second option for its modularity:
constraints derived from previous definitions should not interfere with the size inference of the current definition.
On the other hand, to reduce the overhead of solving constraints,
we choose the first option for local definitions.
The way constraints are added to the environment is inspired by \citet{universes},
which infers universe levels that are prenex polymorphic at definitions.

Unfortunately, even when only solving constraints for global declarations,
our implementation of the size inference algorithm in the Coq codebase takes a rather significant performance hit.
This is in part due to the proliferation of sizes in which the definitions are polymorphic,
as the worst-case time complexity of solving is at least quadratic in the number of size variables.
We analyze the performance of our implementation and discuss possible solutions in \autoref{sec:impl}.

\subsection{Polarities}

\Coinductive definitions in \CIChatminus are also annotated with polarities for each of its parameters, augmenting the subtyping relation.
For example, if the type parameter of the usual $\List$ type has positive polarity,
then $\app{\List^r}{\Nat^s} \leq \app{\List^r}{\Nat^{\succ{s}}}$ holds
because $\Nat^s \leq \Nat^{\succ{s}}$ holds.
It is not known whether these polarity annotations are inferrable from the \coinductive definitions alone,
so again in the name of backward compatibility, \lang does not have these annotations,
and treats all parameters as invariant.
This aligns with Coq's current behaviour, where \coqinline{list Set} is not a subtype of \coqinline{list Type}
despite the presence of cumulativity where \coqinline{Set} is a subtype of \coqinline{Type}.

Unfortunately, the invariance of parameters and subtyping of sized \coinductive types interferes with nested \coinductive types,
where the type itself may appear as a parameter to another type in the type of its constructors.
Subject reduction is violated quite severely: it becomes possible to have a well-typed term that becomes no longer well-typed after a reduction step.
We give an example in \autoref{sec:metatheory} and discuss some solutions,
but the approach \lang takes is to disallow nested \coinductives,
removing them from \CIChatminus.
However, the implementation has no such restriction on nested \coinductives,
and it doesn't appear possible for size inference to produce the kind of annotations that break subject reduction.

\subsection{Position Size Annotations}

Although users are not required to indicate the recursive argument when writing fixpoints in Coq,
they are indicated in the core calculus because Coq's type checker will attempt determine which one it is when not explicitly indicated.
Similarly, \lang has position annotations to indicate which argument is the recursive argument and whether the \cofixpoint preserves sizes or not,
but they are entirely determined during size inference.
This augments the inference algorithm for \CIChat,
which assumes that the annotations are already present.

Note that while inference begins with terms whose position annotations are absent,
we do assume that the recursive arguments are already indicated,
separating what Coq already does from what there is to do to obtain sized types.
In terms of the implementation, one downside of this approach is that not as many programs that \emph{could} pass type checking \emph{do},
due to the existing architecture of the Coq type checker.
We discuss this further in \autoref{sec:impl:recind}.

% TODO: Is it worth mentioning that we remove the restrict to simple types?
% I don't know how to justify it or what its consequences are. (Michael might)

%%% Local Variables:
%%% TeX-master: "../main.tex"
%%% TeX-engine: default
%%% End:
